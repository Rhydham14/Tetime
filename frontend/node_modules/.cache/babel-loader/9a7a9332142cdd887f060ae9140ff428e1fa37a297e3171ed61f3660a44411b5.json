{"ast":null,"code":"import * as e from \"react\";\nimport t from \"react\";\nimport r from \"prop-types\";\nimport n from \"invariant\";\nfunction o() {\n  return o = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n    }\n    return e;\n  }, o.apply(this, arguments);\n}\nfunction a(e, t) {\n  if (null == e) return {};\n  var r,\n    n,\n    o = {},\n    a = Object.keys(e);\n  for (n = 0; n < a.length; n++) t.indexOf(r = a[n]) >= 0 || (o[r] = e[r]);\n  return o;\n}\nconst s = e => {\n    const {\n      search: t,\n      hash: r,\n      href: n,\n      origin: o,\n      protocol: a,\n      host: s,\n      hostname: i,\n      port: c\n    } = e.location;\n    let {\n      pathname: l\n    } = e.location;\n    return !l && n && u && (l = new URL(n).pathname), {\n      pathname: encodeURI(decodeURI(l)),\n      search: t,\n      hash: r,\n      href: n,\n      origin: o,\n      protocol: a,\n      host: s,\n      hostname: i,\n      port: c,\n      state: e.history.state,\n      key: e.history.state && e.history.state.key || \"initial\"\n    };\n  },\n  i = (e, t) => {\n    let r = [],\n      n = s(e),\n      a = !1,\n      i = () => {};\n    return {\n      get location() {\n        return n;\n      },\n      get transitioning() {\n        return a;\n      },\n      _onTransitionComplete() {\n        a = !1, i();\n      },\n      listen(t) {\n        r.push(t);\n        const o = () => {\n          n = s(e), t({\n            location: n,\n            action: \"POP\"\n          });\n        };\n        return e.addEventListener(\"popstate\", o), () => {\n          e.removeEventListener(\"popstate\", o), r = r.filter(e => e !== t);\n        };\n      },\n      navigate(t, {\n        state: c,\n        replace: u = !1\n      } = {}) {\n        if (\"number\" == typeof t) e.history.go(t);else {\n          c = o({}, c, {\n            key: Date.now() + \"\"\n          });\n          try {\n            a || u ? e.history.replaceState(c, null, t) : e.history.pushState(c, null, t);\n          } catch (r) {\n            e.location[u ? \"replace\" : \"assign\"](t);\n          }\n        }\n        n = s(e), a = !0;\n        const l = new Promise(e => i = e);\n        return r.forEach(e => e({\n          location: n,\n          action: \"PUSH\"\n        })), l;\n      }\n    };\n  },\n  c = (e = \"/\") => {\n    const t = e.indexOf(\"?\"),\n      r = {\n        pathname: t > -1 ? e.substr(0, t) : e,\n        search: t > -1 ? e.substr(t) : \"\"\n      };\n    let n = 0;\n    const o = [r],\n      a = [null];\n    return {\n      get location() {\n        return o[n];\n      },\n      addEventListener(e, t) {},\n      removeEventListener(e, t) {},\n      history: {\n        get entries() {\n          return o;\n        },\n        get index() {\n          return n;\n        },\n        get state() {\n          return a[n];\n        },\n        pushState(e, t, r) {\n          const [s, i = \"\"] = r.split(\"?\");\n          n++, o.push({\n            pathname: s,\n            search: i.length ? `?${i}` : i\n          }), a.push(e);\n        },\n        replaceState(e, t, r) {\n          const [s, i = \"\"] = r.split(\"?\");\n          o[n] = {\n            pathname: s,\n            search: i\n          }, a[n] = e;\n        },\n        go(e) {\n          const t = n + e;\n          t < 0 || t > a.length - 1 || (n = t);\n        }\n      }\n    };\n  },\n  u = !(\"undefined\" == typeof window || !window.document || !window.document.createElement),\n  l = i(u ? window : c()),\n  {\n    navigate: p\n  } = l;\nfunction h(e, r) {\n  return t.createServerContext ? ((e, r = null) => (globalThis.__SERVER_CONTEXT || (globalThis.__SERVER_CONTEXT = {}), globalThis.__SERVER_CONTEXT[e] || (globalThis.__SERVER_CONTEXT[e] = t.createServerContext(e, r)), globalThis.__SERVER_CONTEXT[e]))(e, r) : t.createContext(r);\n}\nconst m = h(\"Base\", {\n    baseuri: \"/\",\n    basepath: \"/\"\n  }),\n  d = h(\"Location\"),\n  f = () => e.useContext(m),\n  y = () => e.useContext(d);\nfunction E(e) {\n  this.uri = e;\n}\nconst g = e => e instanceof E,\n  v = e => {\n    throw new E(e);\n  };\nfunction b(t) {\n  const {\n    to: r,\n    replace: n = !0,\n    state: o,\n    noThrow: a,\n    baseuri: s\n  } = t;\n  e.useEffect(() => {\n    Promise.resolve().then(() => {\n      const e = k(r, s);\n      p(P(e, t), {\n        replace: n,\n        state: o\n      });\n    });\n  }, []);\n  const i = k(r, s);\n  return a || v(P(i, t)), null;\n}\nconst R = t => {\n  const r = y(),\n    {\n      baseuri: n\n    } = f(); /*#__PURE__*/\n  return e.createElement(b, o({}, r, {\n    baseuri: n\n  }, t));\n};\nR.propTypes = {\n  from: r.string,\n  to: r.string.isRequired\n};\nconst C = (e, t) => e.substr(0, t.length) === t,\n  w = (e, t) => {\n    let r, o;\n    const [a] = t.split(\"?\"),\n      s = N(a),\n      i = \"\" === s[0],\n      c = j(e);\n    for (let e = 0, a = c.length; e < a; e++) {\n      let a = !1;\n      const u = c[e].route;\n      if (u.default) {\n        o = {\n          route: u,\n          params: {},\n          uri: t\n        };\n        continue;\n      }\n      const l = N(u.path),\n        p = {},\n        h = Math.max(s.length, l.length);\n      let m = 0;\n      for (; m < h; m++) {\n        const e = l[m],\n          t = s[m];\n        if ($(e)) {\n          p[e.slice(1) || \"*\"] = s.slice(m).map(decodeURIComponent).join(\"/\");\n          break;\n        }\n        if (void 0 === t) {\n          a = !0;\n          break;\n        }\n        const r = O.exec(e);\n        if (r && !i) {\n          const e = -1 === U.indexOf(r[1]);\n          n(e, `<Router> dynamic segment \"${r[1]}\" is a reserved name. Please use a different name in path \"${u.path}\".`);\n          const o = decodeURIComponent(t);\n          p[r[1]] = o;\n        } else if (e !== t) {\n          a = !0;\n          break;\n        }\n      }\n      if (!a) {\n        r = {\n          route: u,\n          params: p,\n          uri: \"/\" + s.slice(0, m).join(\"/\")\n        };\n        break;\n      }\n    }\n    return r || o || null;\n  },\n  x = (e, t) => w([{\n    path: e\n  }], t),\n  k = (e, t) => {\n    if (C(e, \"/\")) return e;\n    const [r, n] = e.split(\"?\"),\n      [o] = t.split(\"?\"),\n      a = N(r),\n      s = N(o);\n    if (\"\" === a[0]) return L(o, n);\n    if (!C(a[0], \".\")) {\n      const e = s.concat(a).join(\"/\");\n      return L((\"/\" === o ? \"\" : \"/\") + e, n);\n    }\n    const i = s.concat(a),\n      c = [];\n    for (let e = 0, t = i.length; e < t; e++) {\n      const t = i[e];\n      \"..\" === t ? c.pop() : \".\" !== t && c.push(t);\n    }\n    return L(\"/\" + c.join(\"/\"), n);\n  },\n  P = (e, t) => {\n    const [r, n = \"\"] = e.split(\"?\");\n    let o = \"/\" + N(r).map(e => {\n      const r = O.exec(e);\n      return r ? t[r[1]] : e;\n    }).join(\"/\");\n    const {\n        location: {\n          search: a = \"\"\n        } = {}\n      } = t,\n      s = a.split(\"?\")[1] || \"\";\n    return o = L(o, n, s), o;\n  },\n  T = (e, t) => {\n    const r = e => _(e);\n    return N(e).filter(r).sort().join(\"/\") === N(t).filter(r).sort().join(\"/\");\n  },\n  O = /^:(.+)/,\n  _ = e => O.test(e),\n  $ = e => e && \"*\" === e[0],\n  S = (e, t) => ({\n    route: e,\n    score: e.default ? 0 : N(e.path).reduce((e, t) => (e += 4, (e => \"\" === e)(t) ? e += 1 : _(t) ? e += 2 : $(t) ? e -= 5 : e += 3, e), 0),\n    index: t\n  }),\n  j = e => e.map(S).sort((e, t) => e.score < t.score ? 1 : e.score > t.score ? -1 : e.index - t.index),\n  N = e => e.replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\"),\n  L = (e, ...t) => e + ((t = t.filter(e => e && e.length > 0)) && t.length > 0 ? `?${t.join(\"&\")}` : \"\"),\n  U = [\"uri\", \"path\"],\n  D = (e, t) => {\n    const r = Object.keys(e);\n    return r.length === Object.keys(t).length && r.every(r => t.hasOwnProperty(r) && e[r] === t[r]);\n  },\n  M = e => e.replace(/(^\\/+|\\/+$)/g, \"\"),\n  I = t => r => {\n    if (!r) return null;\n    if (r.type === e.Fragment && r.props.children) return e.Children.map(r.props.children, I(t));\n    if (n(r.props.path || r.props.default || r.type === R, `<Router>: Children of <Router> must have a \\`path\\` or \\`default\\` prop, or be a \\`<Redirect>\\`. None found on element type \\`${r.type}\\``), n(!!(r.type !== R || r.props.from && r.props.to), `<Redirect from=\"${r.props.from}\" to=\"${r.props.to}\"/> requires both \"from\" and \"to\" props when inside a <Router>.`), n(!(r.type === R && !T(r.props.from, r.props.to)), `<Redirect from=\"${r.props.from} to=\"${r.props.to}\"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.`), r.props.default) return {\n      value: r,\n      default: !0\n    };\n    const o = r.type === R ? r.props.from : r.props.path,\n      a = \"/\" === o ? t : `${M(t)}/${M(o)}`;\n    return {\n      value: r,\n      default: r.props.default,\n      path: r.props.children ? `${M(a)}/*` : a\n    };\n  },\n  V = [\"innerRef\"],\n  q = [\"to\", \"state\", \"replace\", \"getProps\"],\n  X = [\"key\"];\nlet {\n  forwardRef: B\n} = e;\nvoid 0 === B && (B = e => e);\nconst K = () => {},\n  A = B((t, r) => {\n    let {\n        innerRef: n\n      } = t,\n      s = a(t, V);\n    const {\n        baseuri: i\n      } = f(),\n      {\n        location: c\n      } = y(),\n      {\n        to: u,\n        state: l,\n        replace: h,\n        getProps: m = K\n      } = s,\n      d = a(s, q),\n      E = k(u, i),\n      g = encodeURI(E),\n      v = c.pathname === g,\n      b = C(c.pathname, g); /*#__PURE__*/\n    return e.createElement(\"a\", o({\n      ref: r || n,\n      \"aria-current\": v ? \"page\" : void 0\n    }, d, m({\n      isCurrent: v,\n      isPartiallyCurrent: b,\n      href: E,\n      location: c\n    }), {\n      href: E,\n      onClick: e => {\n        if (d.onClick && d.onClick(e), (e => !e.defaultPrevented && 0 === e.button && !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey))(e)) {\n          e.preventDefault();\n          let t = h;\n          if (\"boolean\" != typeof h && v) {\n            const e = a(o({}, c.state), X);\n            t = D(o({}, l), e);\n          }\n          p(E, {\n            state: l,\n            replace: t\n          });\n        }\n      }\n    }));\n  });\nA.displayName = \"Link\", A.propTypes = {\n  to: r.string.isRequired\n};\nclass F extends e.Component {\n  constructor(...e) {\n    super(...e), this.displayName = \"ReactUseErrorBoundary\";\n  }\n  componentDidCatch(...e) {\n    this.setState({}), this.props.onError(...e);\n  }\n  render() {\n    return this.props.children;\n  }\n}\nconst W = e.createContext({\n  componentDidCatch: {\n    current: void 0\n  },\n  error: void 0,\n  setError: () => !1\n});\nfunction H({\n  children: t\n}) {\n  const [r, n] = e.useState(),\n    o = e.useRef(),\n    a = e.useMemo(() => ({\n      componentDidCatch: o,\n      error: r,\n      setError: n\n    }), [r]); /*#__PURE__*/\n  return e.createElement(W.Provider, {\n    value: a\n  }, /*#__PURE__*/e.createElement(F, {\n    error: r,\n    onError: (e, t) => {\n      n(e), null == o.current || o.current(e, t);\n    }\n  }, t));\n}\nH.displayName = \"ReactUseErrorBoundaryContext\";\nconst z = function (t) {\n    var r, n;\n    function a(r) {\n      /*#__PURE__*/return e.createElement(H, null, /*#__PURE__*/e.createElement(t, o({\n        key: \"WrappedComponent\"\n      }, r)));\n    }\n    return a.displayName = `WithErrorBoundary(${null != (r = null != (n = t.displayName) ? n : t.name) ? r : \"Component\"})`, a;\n  }(({\n    history: t = l,\n    children: r\n  }) => {\n    const {\n        location: n\n      } = t,\n      [o, a] = e.useState({\n        location: n\n      }),\n      [s] = function (t) {\n        const r = e.useContext(W);\n        r.componentDidCatch.current = void 0;\n        const n = e.useCallback(() => {\n          r.setError(void 0);\n        }, []);\n        return [r.error, n];\n      }();\n    if (e.useEffect(() => {\n      t._onTransitionComplete();\n    }, [o.location]), e.useEffect(() => {\n      let e = !1;\n      const r = t.listen(({\n        location: t\n      }) => {\n        Promise.resolve().then(() => {\n          requestAnimationFrame(() => {\n            e || a({\n              location: t\n            });\n          });\n        });\n      });\n      return () => {\n        e = !0, r();\n      };\n    }, []), s) {\n      if (!g(s)) throw s;\n      p(s.uri, {\n        replace: !0\n      });\n    } /*#__PURE__*/\n    return e.createElement(d.Provider, {\n      value: o\n    }, \"function\" == typeof r ? r(o) : r || null);\n  }),\n  G = ({\n    children: t\n  }) => {\n    const r = y();\n    return r ? t(r) : /*#__PURE__*/e.createElement(z, null, t);\n  },\n  J = ({\n    url: t,\n    children: r\n  }) => {\n    const n = t.indexOf(\"?\");\n    let o,\n      a = \"\";\n    return n > -1 ? (o = t.substring(0, n), a = t.substring(n)) : o = t, /*#__PURE__*/e.createElement(d.Provider, {\n      value: {\n        location: {\n          pathname: o,\n          search: a,\n          hash: \"\"\n        }\n      }\n    }, r);\n  },\n  Q = ({\n    path: e,\n    children: t\n  }) => {\n    const {\n        baseuri: r\n      } = f(),\n      {\n        location: n\n      } = y(),\n      a = k(e, r),\n      s = x(a, n.pathname);\n    return t({\n      location: n,\n      match: s ? o({}, s.params, {\n        uri: s.uri,\n        path: e\n      }) : null\n    });\n  },\n  Y = [\"uri\", \"location\", \"component\"],\n  Z = [\"children\", \"style\", \"component\", \"uri\", \"location\"],\n  ee = t => {\n    let {\n        uri: r,\n        location: n,\n        component: s\n      } = t,\n      i = a(t, Y); /*#__PURE__*/\n    return e.createElement(re, o({}, i, {\n      component: s,\n      uri: r,\n      location: n\n    }));\n  };\nlet te = 0;\nconst re = t => {\n    let {\n        children: r,\n        style: n,\n        component: s = \"div\",\n        uri: i,\n        location: c\n      } = t,\n      u = a(t, Z);\n    const l = e.useRef(),\n      p = e.useRef(!0),\n      h = e.useRef(i),\n      m = e.useRef(c.pathname),\n      d = e.useRef(!1);\n    e.useEffect(() => (te++, f(), () => {\n      te--, 0 === te && (p.current = !0);\n    }), []), e.useEffect(() => {\n      let e = !1,\n        t = !1;\n      i !== h.current && (h.current = i, e = !0), c.pathname !== m.current && (m.current = c.pathname, t = !0), d.current = e || t && c.pathname === i, d.current && f();\n    }, [i, c]);\n    const f = e.useCallback(() => {\n      var e;\n      \"test\" !== process.env.NODE_ENV && (p.current ? p.current = !1 : (e = l.current, d.current && e && e.focus()));\n    }, []); /*#__PURE__*/\n    return e.createElement(s, o({\n      style: o({\n        outline: \"none\"\n      }, n),\n      tabIndex: \"-1\",\n      ref: l\n    }, u), r);\n  },\n  ne = [\"location\", \"primary\", \"children\", \"basepath\", \"baseuri\", \"component\"],\n  oe = t => {\n    const r = f(),\n      n = y(); /*#__PURE__*/\n    return e.createElement(ae, o({}, r, n, t));\n  };\nfunction ae(t) {\n  const {\n      location: r,\n      primary: n = !0,\n      children: s,\n      basepath: i,\n      component: c = \"div\"\n    } = t,\n    u = a(t, ne),\n    l = e.Children.toArray(s).reduce((e, t) => {\n      const r = I(i)(t);\n      return e.concat(r);\n    }, []),\n    {\n      pathname: p\n    } = r,\n    h = w(l, p);\n  if (h) {\n    const {\n        params: t,\n        uri: a,\n        route: s,\n        route: {\n          value: l\n        }\n      } = h,\n      p = s.default ? i : s.path.replace(/\\*$/, \"\"),\n      d = o({}, t, {\n        uri: a,\n        location: r\n      }),\n      f = e.cloneElement(l, d, l.props.children ? /*#__PURE__*/e.createElement(oe, {\n        location: r,\n        primary: n\n      }, l.props.children) : void 0),\n      y = n ? ee : c,\n      E = n ? o({\n        uri: a,\n        location: r,\n        component: c\n      }, u) : u; /*#__PURE__*/\n    return e.createElement(m.Provider, {\n      value: {\n        baseuri: a,\n        basepath: p\n      }\n    }, /*#__PURE__*/e.createElement(y, E, f));\n  }\n  return null;\n}\nconst se = () => {\n    const e = y();\n    if (!e) throw new Error(\"useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\");\n    return e.location;\n  },\n  ie = () => {\n    throw new Error(\"useNavigate is removed. Use import { navigate } from 'gatsby' instead\");\n  },\n  ce = () => {\n    const e = f();\n    if (!e) throw new Error(\"useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\");\n    const t = se(),\n      r = x(e.basepath, t.pathname);\n    return r ? r.params : null;\n  },\n  ue = e => {\n    if (!e) throw new Error(\"useMatch(path: string) requires an argument of a string to match against\");\n    const t = f();\n    if (!t) throw new Error(\"useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\");\n    const r = se(),\n      n = k(e, t.baseuri),\n      a = x(n, r.pathname);\n    return a ? o({}, a.params, {\n      uri: a.uri,\n      path: e\n    }) : null;\n  };\nexport { m as BaseContext, A as Link, G as Location, d as LocationContext, z as LocationProvider, Q as Match, R as Redirect, oe as Router, J as ServerLocation, i as createHistory, c as createMemorySource, l as globalHistory, P as insertParams, g as isRedirect, x as match, p as navigate, w as pick, v as redirectTo, k as resolve, D as shallowCompare, C as startsWith, f as useBaseContext, se as useLocation, y as useLocationContext, ue as useMatch, ie as useNavigate, ce as useParams, T as validateRedirect };","map":{"version":3,"names":["s","e","search","t","hash","r","href","n","origin","o","protocol","a","host","hostname","i","port","c","location","pathname","l","u","URL","encodeURI","decodeURI","state","history","key","resolveTransition","transitioning","_onTransitionComplete","listen","push","popstateListener","action","addEventListener","removeEventListener","filter","navigate","replace","go","Date","now","replaceState","pushState","Promise","forEach","createMemorySource","indexOf","substr","entries","index","split","length","window","document","createElement","p","h","createServerContext","globalThis","__SERVER_CONTEXT","createContext","m","baseuri","basepath","d","f","useContext","y","useLocationContext","E","uri","g","v","b","to","noThrow","useEffect","resolve","then","k","P","R","propTypes","from","string","isRequired","C","startsWith","w","N","j","route","default","params","path","Math","max","$","slice","map","decodeURIComponent","join","O","exec","U","x","match","L","concat","pop","T","constructedPath","_","sort","test","S","score","reduce","addQuery","D","Object","keys","every","hasOwnProperty","M","I","type","Fragment","props","children","Children","value","V","q","X","forwardRef","B","K","A","innerRef","getProps","ref","isCurrent","isPartiallyCurrent","onClick","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","displayName","F","Component","constructor","componentDidCatch","setState","onError","render","W","current","error","setError","H","useState","useRef","useMemo","Provider","z","name","useCallback","requestAnimationFrame","G","Location","J","ServerLocation","url","substring","Q","Match","Y","Z","ee","component","re","te","style","process","env","NODE_ENV","focus","outline","tabIndex","ne","oe","ae","primary","toArray","cloneElement","se","useLocation","Error","ie","useNavigate","ce","useParams","ue","BaseContext","Link","LocationContext","LocationProvider","Redirect","Router","createHistory","globalHistory","insertParams","isRedirect","pick","redirectTo","shallowCompare","useBaseContext","useMatch","validateRedirect"],"sources":["/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/history.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/hooks-create-context.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/hooks-use-context.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/redirect.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/utils.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/link.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/error-boundary.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/location-provider.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/location.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/location-server.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/match.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/focus-handler.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/lib/router.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/hooks/use-location.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/hooks/use-navigate.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/hooks/use-params.js","/home/rhydham/Documents/Tetime/frontend/node_modules/@gatsbyjs/reach-router/src/hooks/use-match.js"],"sourcesContent":["const getLocation = source => {\n  const { search, hash, href, origin, protocol, host, hostname, port } =\n    source.location\n  let { pathname } = source.location\n\n  if (!pathname && href && canUseDOM) {\n    const url = new URL(href)\n    pathname = url.pathname\n  }\n\n  return {\n    pathname: encodeURI(decodeURI(pathname)),\n    search,\n    hash,\n    href,\n    origin,\n    protocol,\n    host,\n    hostname,\n    port,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\",\n  }\n}\n\nconst createHistory = (source, options) => {\n  let listeners = []\n  let location = getLocation(source)\n  let transitioning = false\n  let resolveTransition = () => {}\n\n  return {\n    get location() {\n      return location\n    },\n\n    get transitioning() {\n      return transitioning\n    },\n\n    _onTransitionComplete() {\n      transitioning = false\n      resolveTransition()\n    },\n\n    listen(listener) {\n      listeners.push(listener)\n\n      const popstateListener = () => {\n        location = getLocation(source)\n        listener({ location, action: \"POP\" })\n      }\n\n      source.addEventListener(\"popstate\", popstateListener)\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener)\n        listeners = listeners.filter(fn => fn !== listener)\n      }\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      if (typeof to === \"number\") {\n        source.history.go(to)\n      } else {\n        state = { ...state, key: Date.now() + \"\" }\n        // try...catch iOS Safari limits to 100 pushState calls\n        try {\n          if (transitioning || replace) {\n            source.history.replaceState(state, null, to)\n          } else {\n            source.history.pushState(state, null, to)\n          }\n        } catch (e) {\n          source.location[replace ? \"replace\" : \"assign\"](to)\n        }\n      }\n\n      location = getLocation(source)\n      transitioning = true\n      const transition = new Promise(res => (resolveTransition = res))\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }))\n      return transition\n    },\n  }\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nconst createMemorySource = (initialPath = \"/\") => {\n  const searchIndex = initialPath.indexOf(\"?\")\n  const initialLocation = {\n    pathname:\n      searchIndex > -1 ? initialPath.substr(0, searchIndex) : initialPath,\n    search: searchIndex > -1 ? initialPath.substr(searchIndex) : \"\",\n  }\n  let index = 0\n  const stack = [initialLocation]\n  const states = [null]\n\n  return {\n    get location() {\n      return stack[index]\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack\n      },\n      get index() {\n        return index\n      },\n      get state() {\n        return states[index]\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        index++\n        stack.push({ pathname, search: search.length ? `?${search}` : search })\n        states.push(state)\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        stack[index] = { pathname, search }\n        states[index] = state\n      },\n      go(to) {\n        const newIndex = index + to\n\n        if (newIndex < 0 || newIndex > states.length - 1) {\n          return\n        }\n\n        index = newIndex\n      },\n    },\n  }\n}\n\n// global history - uses window.history as the source if available, otherwise a\n// memory history\nconst canUseDOM = !!(\n  typeof window !== \"undefined\" &&\n  window.document &&\n  window.document.createElement\n)\nconst getSource = () => {\n  return canUseDOM ? window : createMemorySource()\n}\n\nconst globalSource = getSource()\nconst globalHistory = createHistory(globalSource)\nconst { navigate } = globalHistory\n\nexport { globalHistory, navigate, createHistory, createMemorySource }\n","/* eslint-disable no-undef */\n\nimport React from \"react\"\n\nconst createServerContext = (name, defaultValue = null) => {\n  if (!globalThis.__SERVER_CONTEXT) {\n    globalThis.__SERVER_CONTEXT = {}\n  }\n\n  if (!globalThis.__SERVER_CONTEXT[name]) {\n    globalThis.__SERVER_CONTEXT[name] = React.createServerContext(\n      name,\n      defaultValue\n    )\n  }\n\n  return globalThis.__SERVER_CONTEXT[name]\n}\n\nfunction createServerOrClientContext(name, defaultValue) {\n  if (React.createServerContext) {\n    return createServerContext(name, defaultValue)\n  }\n\n  return React.createContext(defaultValue)\n}\n\nexport const BaseContext = createServerOrClientContext(\"Base\", {\n  baseuri: \"/\",\n  basepath: \"/\",\n})\nexport const LocationContext = createServerOrClientContext(\"Location\")\n","import * as React from \"react\"\nimport { BaseContext, LocationContext } from \"./hooks-create-context\"\n\nexport const useBaseContext = () => React.useContext(BaseContext)\nexport const useLocationContext = () => React.useContext(LocationContext)\n","import * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, insertParams } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nfunction RedirectRequest(uri) {\n  this.uri = uri\n}\n\nconst isRedirect = o => o instanceof RedirectRequest\n\nconst redirectTo = to => {\n  throw new RedirectRequest(to)\n}\n\nfunction RedirectImpl(props) {\n  const { to, replace = true, state, noThrow, baseuri } = props\n\n  React.useEffect(() => {\n    Promise.resolve().then(() => {\n      const resolvedTo = resolve(to, baseuri)\n      navigate(insertParams(resolvedTo, props), { replace, state })\n    })\n  }, [])\n\n  const resolvedTo = resolve(to, baseuri)\n\n  if (!noThrow) {\n    redirectTo(insertParams(resolvedTo, props))\n  }\n\n  return null\n}\n\nconst Redirect = props => {\n  const locationContext = useLocationContext()\n  const { baseuri } = useBaseContext()\n\n  return <RedirectImpl {...locationContext} baseuri={baseuri} {...props} />\n}\n\nRedirect.propTypes = {\n  from: PropTypes.string,\n  to: PropTypes.string.isRequired,\n}\n\nexport { Redirect, isRedirect, redirectTo }\n","import * as React from \"react\"\nimport invariant from \"invariant\"\nimport { Redirect } from \"./redirect\"\n\n/**\n * startsWith(string, search) - Check if `string` starts with `search`\n */\nconst startsWith = (string, search) => {\n  return string.substr(0, search.length) === search\n}\n\n/**\n * pick(routes, uri)\n\n  Ranks and picks the best route to match. Each segment gets the highest\n  amount of points, then the type of segment gets an additional amount of\n  points where\n\n      static > dynamic > splat > root\n\n  This way we don't have to worry about the order of our routes, let the\n  computers do it.\n\n  A route looks like this\n\n      { path, default, value }\n\n  And a returned match looks like:\n\n      { route, params, uri }\n\n  I know, I should use TypeScript not comments for these types. \n */\nconst pick = (routes, uri) => {\n  let match\n  let default_\n\n  const [uriPathname] = uri.split(\"?\")\n  const uriSegments = segmentize(uriPathname)\n  const isRootUri = uriSegments[0] === \"\"\n  const ranked = rankRoutes(routes)\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    let missed = false\n    const route = ranked[i].route\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri,\n      }\n      continue\n    }\n\n    const routeSegments = segmentize(route.path)\n    const params = {}\n    const max = Math.max(uriSegments.length, routeSegments.length)\n    let index = 0\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index]\n      const uriSegment = uriSegments[index]\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        const param = routeSegment.slice(1) || \"*\"\n        params[param] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\")\n        break\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true\n        break\n      }\n\n      const dynamicMatch = paramRe.exec(routeSegment)\n\n      if (dynamicMatch && !isRootUri) {\n        const matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1\n        invariant(\n          matchIsNotReserved,\n          `<Router> dynamic segment \"${dynamicMatch[1]}\" is a reserved name. Please use a different name in path \"${route.path}\".`\n        )\n        const value = decodeURIComponent(uriSegment)\n        params[dynamicMatch[1]] = value\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true\n        break\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\"),\n      }\n      break\n    }\n  }\n\n  return match || default_ || null\n}\n\n/**\n * match(path, uri) - Matches just one path to a uri, also lol\n */\nconst match = (path, uri) => pick([{ path }], uri)\n\n/**\n * resolve(to, basepath)\n\n  Resolves URIs as though every path is a directory, no files.  Relative URIs\n  in the browser can feel awkward because not only can you be \"in a directory\"\n  you can be \"at a file\", too. For example\n\n      browserSpecResolve('foo', '/bar/') => /bar/foo\n      browserSpecResolve('foo', '/bar') => /foo\n\n  But on the command line of a file system, it's not as complicated, you can't\n  `cd` from a file, only directories.  This way, links have to know less about\n  their current path. To go deeper you can do this:\n\n      <Link to=\"deeper\"/>\n      // instead of\n      <Link to=`{${props.uri}/deeper}`/>\n\n  Just like `cd`, if you want to go deeper from the command line, you do this:\n\n      cd deeper\n      // not\n      cd $(pwd)/deeper\n\n  By treating every path as a directory, linking to relative paths should\n  require less contextual information and (fingers crossed) be more intuitive.\n */\nconst resolve = (to, base) => {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\")\n  const [basePathname] = base.split(\"?\")\n\n  const toSegments = segmentize(toPathname)\n  const baseSegments = segmentize(basePathname)\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery)\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\")\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery)\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments)\n  const segments = []\n  for (let i = 0, l = allSegments.length; i < l; i++) {\n    const segment = allSegments[i]\n    if (segment === \"..\") segments.pop()\n    else if (segment !== \".\") segments.push(segment)\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery)\n}\n\nconst insertParams = (path, params) => {\n  const [pathBase, query = \"\"] = path.split(\"?\")\n  const segments = segmentize(pathBase)\n  let constructedPath =\n    \"/\" +\n    segments\n      .map(segment => {\n        const match = paramRe.exec(segment)\n        return match ? params[match[1]] : segment\n      })\n      .join(\"/\")\n  const { location: { search = \"\" } = {} } = params\n  const searchSplit = search.split(\"?\")[1] || \"\"\n  constructedPath = addQuery(constructedPath, query, searchSplit)\n  return constructedPath\n}\n\nconst validateRedirect = (from, to) => {\n  const filter = segment => isDynamic(segment)\n  const fromString = segmentize(from).filter(filter).sort().join(\"/\")\n  const toString = segmentize(to).filter(filter).sort().join(\"/\")\n  return fromString === toString\n}\n\nconst paramRe = /^:(.+)/\n\nconst SEGMENT_POINTS = 4\nconst STATIC_POINTS = 3\nconst DYNAMIC_POINTS = 2\nconst SPLAT_PENALTY = 1\nconst ROOT_POINTS = 1\n\nconst isRootSegment = segment => segment === \"\"\nconst isDynamic = segment => paramRe.test(segment)\nconst isSplat = segment => segment && segment[0] === \"*\"\n\nconst rankRoute = (route, index) => {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS\n        if (isRootSegment(segment)) score += ROOT_POINTS\n        else if (isDynamic(segment)) score += DYNAMIC_POINTS\n        else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY\n        else score += STATIC_POINTS\n        return score\n      }, 0)\n  return { route, score, index }\n}\n\nconst rankRoutes = routes =>\n  routes\n    .map(rankRoute)\n    .sort((a, b) =>\n      a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n    )\n\nconst segmentize = uri =>\n  uri\n    // strip starting/ending slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")\n    .split(\"/\")\n\nconst addQuery = (pathname, ...query) => {\n  query = query.filter(q => q && q.length > 0)\n  return pathname + (query && query.length > 0 ? `?${query.join(\"&\")}` : \"\")\n}\n\nconst reservedNames = [\"uri\", \"path\"]\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nconst shallowCompare = (obj1, obj2) => {\n  const obj1Keys = Object.keys(obj1)\n  return (\n    obj1Keys.length === Object.keys(obj2).length &&\n    obj1Keys.every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key])\n  )\n}\n\nconst stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\")\n\nconst createRoute = basepath => element => {\n  if (!element) {\n    return null\n  }\n\n  if (element.type === React.Fragment && element.props.children) {\n    return React.Children.map(element.props.children, createRoute(basepath))\n  }\n  invariant(\n    element.props.path || element.props.default || element.type === Redirect,\n    `<Router>: Children of <Router> must have a \\`path\\` or \\`default\\` prop, or be a \\`<Redirect>\\`. None found on element type \\`${element.type}\\``\n  )\n\n  invariant(\n    !(element.type === Redirect && (!element.props.from || !element.props.to)),\n    `<Redirect from=\"${element.props.from}\" to=\"${element.props.to}\"/> requires both \"from\" and \"to\" props when inside a <Router>.`\n  )\n\n  invariant(\n    !(\n      element.type === Redirect &&\n      !validateRedirect(element.props.from, element.props.to)\n    ),\n    `<Redirect from=\"${element.props.from} to=\"${element.props.to}\"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.`\n  )\n\n  if (element.props.default) {\n    return { value: element, default: true }\n  }\n\n  const elementPath =\n    element.type === Redirect ? element.props.from : element.props.path\n\n  const path =\n    elementPath === \"/\"\n      ? basepath\n      : `${stripSlashes(basepath)}/${stripSlashes(elementPath)}`\n\n  return {\n    value: element,\n    default: element.props.default,\n    path: element.props.children ? `${stripSlashes(path)}/*` : path,\n  }\n}\n\nconst shouldNavigate = event =>\n  !event.defaultPrevented &&\n  event.button === 0 &&\n  !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n\nexport {\n  startsWith,\n  pick,\n  match,\n  resolve,\n  insertParams,\n  validateRedirect,\n  shallowCompare,\n  createRoute,\n  shouldNavigate,\n}\n","/* eslint-disable jsx-a11y/anchor-has-content */\nimport * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, startsWith, shouldNavigate, shallowCompare } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nlet { forwardRef } = React\n\nif (typeof forwardRef === \"undefined\") {\n  forwardRef = C => C\n}\n\nconst k = () => {}\n\nexport const Link = forwardRef(({ innerRef, ...props }, ref) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const { to, state, replace, getProps = k, ...anchorProps } = props\n  const href = resolve(to, baseuri)\n  const encodedHref = encodeURI(href)\n  const isCurrent = location.pathname === encodedHref\n  const isPartiallyCurrent = startsWith(location.pathname, encodedHref)\n\n  return (\n    <a\n      ref={ref || innerRef}\n      aria-current={isCurrent ? \"page\" : undefined}\n      {...anchorProps}\n      {...getProps({ isCurrent, isPartiallyCurrent, href, location })}\n      href={href}\n      onClick={event => {\n        if (anchorProps.onClick) anchorProps.onClick(event)\n        if (shouldNavigate(event)) {\n          event.preventDefault()\n          let shouldReplace = replace\n          if (typeof replace !== \"boolean\" && isCurrent) {\n            const { key, ...restState } = { ...location.state }\n            shouldReplace = shallowCompare({ ...state }, restState)\n          }\n          navigate(href, {\n            state,\n            replace: shouldReplace,\n          })\n        }\n      }}\n    />\n  )\n})\n\nLink.displayName = \"Link\"\n\nLink.propTypes = {\n  to: PropTypes.string.isRequired,\n}\n","// MIT LICENSE - Taken from: https://github.com/tatethurston/react-use-error-boundary/blob/525225a34d4ad50f52b5f5ac8731cdf6999cf8a8/src/index.tsx\n\nimport * as React from \"react\"\n\nclass ErrorBoundary extends React.Component {\n  displayName = \"ReactUseErrorBoundary\"\n\n  componentDidCatch(...args) {\n    // silence React warning:\n    // ErrorBoundary: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI\n    this.setState({})\n    this.props.onError(...args)\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nconst noop = () => false\n\nconst errorBoundaryContext = React.createContext({\n  componentDidCatch: { current: undefined },\n  error: undefined,\n  setError: noop,\n})\n\nexport function ErrorBoundaryContext({ children }) {\n  const [error, setError] = React.useState()\n  const componentDidCatch = React.useRef()\n  const ctx = React.useMemo(\n    () => ({\n      componentDidCatch,\n      error,\n      setError,\n    }),\n    [error]\n  )\n  return (\n    <errorBoundaryContext.Provider value={ctx}>\n      <ErrorBoundary\n        error={error}\n        onError={(error, errorInfo) => {\n          setError(error)\n          componentDidCatch.current?.(error, errorInfo)\n        }}\n      >\n        {children}\n      </ErrorBoundary>\n    </errorBoundaryContext.Provider>\n  )\n}\nErrorBoundaryContext.displayName = \"ReactUseErrorBoundaryContext\"\n\nexport function withErrorBoundary(WrappedComponent) {\n  function WithErrorBoundary(props) {\n    return (\n      <ErrorBoundaryContext>\n        <WrappedComponent key=\"WrappedComponent\" {...props} />\n      </ErrorBoundaryContext>\n    )\n  }\n  WithErrorBoundary.displayName = `WithErrorBoundary(${\n    WrappedComponent.displayName ?? WrappedComponent.name ?? \"Component\"\n  })`\n\n  return WithErrorBoundary\n}\n\nexport function useErrorBoundary(componentDidCatch) {\n  const ctx = React.useContext(errorBoundaryContext)\n  ctx.componentDidCatch.current = componentDidCatch\n  const resetError = React.useCallback(() => {\n    ctx.setError(undefined)\n  }, [])\n\n  return [ctx.error, resetError]\n}\n","import * as React from \"react\"\nimport { globalHistory, navigate } from \"./history\"\nimport { isRedirect } from \"./redirect\"\nimport { LocationContext } from \"./hooks-create-context\"\nimport { withErrorBoundary, useErrorBoundary } from \"./error-boundary\"\n\nexport const LocationProvider = withErrorBoundary(\n  ({ history = globalHistory, children }) => {\n    const { location } = history\n\n    const [context, setContext] = React.useState({ location })\n    const [error] = useErrorBoundary()\n\n    React.useEffect(() => {\n      history._onTransitionComplete()\n    }, [context.location])\n\n    React.useEffect(() => {\n      let isCancelled = false\n      const unlisten = history.listen(({ location }) => {\n        Promise.resolve().then(() => {\n          requestAnimationFrame(() => {\n            if (!isCancelled) {\n              setContext({ location })\n            }\n          })\n        })\n      })\n      return () => {\n        isCancelled = true\n        unlisten()\n      }\n    }, [])\n\n    if (error) {\n      if (isRedirect(error)) {\n        navigate(error.uri, { replace: true })\n      } else {\n        throw error\n      }\n    }\n\n    return (\n      <LocationContext.Provider value={context}>\n        {typeof children === \"function\" ? children(context) : children || null}\n      </LocationContext.Provider>\n    )\n  }\n)\n","import * as React from \"react\"\nimport { useLocationContext } from \"./hooks-use-context\"\nimport { LocationProvider } from \"./location-provider\"\n\nexport const Location = ({ children }) => {\n  const context = useLocationContext()\n\n  if (context) {\n    return children(context)\n  } else {\n    return <LocationProvider>{children}</LocationProvider>\n  }\n}\n","import * as React from \"react\"\nimport { LocationContext } from \"./hooks-create-context\"\n\nexport const ServerLocation = ({ url, children }) => {\n  const searchIndex = url.indexOf(\"?\")\n  const searchExists = searchIndex > -1\n  let pathname\n  let search = \"\"\n  const hash = \"\"\n\n  if (searchExists) {\n    pathname = url.substring(0, searchIndex)\n    search = url.substring(searchIndex)\n  } else {\n    pathname = url\n  }\n\n  return (\n    <LocationContext.Provider\n      value={{\n        location: {\n          pathname,\n          search,\n          hash,\n        },\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  )\n}\n","import { useBaseContext, useLocationContext } from \"./hooks-use-context\"\nimport { resolve, match } from \"./utils\"\n\nconst Match = ({ path, children }) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const resolvedPath = resolve(path, baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return children({\n    location,\n    match: result\n      ? {\n          ...result.params,\n          uri: result.uri,\n          path,\n        }\n      : null,\n  })\n}\n\nexport { Match }\n","import * as React from \"react\"\n\nexport const FocusHandler = ({ uri, location, component, ...domProps }) => {\n  return (\n    <FocusHandlerImpl\n      {...domProps}\n      component={component}\n      uri={uri}\n      location={location}\n    />\n  )\n}\n\nlet focusHandlerCount = 0\n\nconst FocusHandlerImpl = ({\n  children,\n  style,\n  component: Comp = \"div\",\n  uri,\n  location,\n  ...domProps\n}) => {\n  const focusWrapperRef = React.useRef()\n  const initialRenderRef = React.useRef(true)\n  const uriRef = React.useRef(uri)\n  const pathnameRef = React.useRef(location.pathname)\n  const shouldFocusRef = React.useRef(false)\n\n  const _requestFocus = requestNode => {\n    if (shouldFocusRef.current && requestNode) {\n      requestNode.focus()\n    }\n  }\n\n  // Initial mount/unmount logic\n  React.useEffect(() => {\n    focusHandlerCount++\n    focus()\n\n    return () => {\n      focusHandlerCount--\n      if (focusHandlerCount === 0) {\n        initialRenderRef.current = true\n      }\n    }\n  }, [])\n\n  // Subsequent navigation logic\n  React.useEffect(() => {\n    let uriChanged = false\n    let pathnameChanged = false\n\n    if (uri !== uriRef.current) {\n      uriRef.current = uri\n      uriChanged = true\n    }\n\n    if (location.pathname !== pathnameRef.current) {\n      pathnameRef.current = location.pathname\n      pathnameChanged = true\n    }\n\n    const navigatedUpToMe = pathnameChanged && location.pathname === uri\n\n    shouldFocusRef.current = uriChanged || navigatedUpToMe\n\n    if (shouldFocusRef.current) {\n      focus()\n    }\n  }, [uri, location])\n\n  const focus = React.useCallback(() => {\n    if (process.env.NODE_ENV === \"test\") {\n      // TODO: Check if change for tests still needed\n      return\n    }\n\n    // Don't focus the <Comp /> on initial render\n    if (initialRenderRef.current) {\n      initialRenderRef.current = false\n    } else {\n      _requestFocus(focusWrapperRef.current)\n    }\n  }, [])\n\n  return (\n    <Comp\n      style={{ outline: \"none\", ...style }}\n      tabIndex=\"-1\"\n      ref={focusWrapperRef}\n      {...domProps}\n    >\n      {children}\n    </Comp>\n  )\n}\n","import * as React from \"react\"\nimport { BaseContext } from \"./hooks-create-context\"\nimport { createRoute, pick } from \"./utils\"\nimport { FocusHandler } from \"./focus-handler\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nexport const Router = props => {\n  const baseContext = useBaseContext()\n  const locationContext = useLocationContext()\n\n  return <RouterImpl {...baseContext} {...locationContext} {...props} />\n}\n\nfunction RouterImpl(props) {\n  const {\n    location,\n    primary = true,\n    children,\n    basepath,\n    baseuri,\n    component = \"div\",\n    ...domProps\n  } = props\n\n  const routes = React.Children.toArray(children).reduce((array, child) => {\n    const routes = createRoute(basepath)(child)\n    return array.concat(routes)\n  }, [])\n  const { pathname } = location\n  const match = pick(routes, pathname)\n\n  if (match) {\n    const {\n      params,\n      uri,\n      route,\n      route: { value: element },\n    } = match\n\n    // remove the /* from the end for child routes relative paths\n    const normalizedBasePath = route.default\n      ? basepath\n      : route.path.replace(/\\*$/, \"\")\n\n    const props = {\n      ...params,\n      uri,\n      location,\n    }\n\n    const clone = React.cloneElement(\n      element,\n      props,\n      element.props.children ? (\n        <Router location={location} primary={primary}>\n          {element.props.children}\n        </Router>\n      ) : undefined\n    )\n\n    // using 'div' for < 16.3 support\n    const FocusWrapper = primary ? FocusHandler : component\n    // don't pass any props to 'div'\n    const wrapperProps = primary\n      ? { uri, location, component, ...domProps }\n      : domProps\n\n    return (\n      <BaseContext.Provider\n        value={{ baseuri: uri, basepath: normalizedBasePath }}\n      >\n        <FocusWrapper {...wrapperProps}>{clone}</FocusWrapper>\n      </BaseContext.Provider>\n    )\n  } else {\n    return null\n  }\n}\n","import { useLocationContext } from \"../lib/hooks-use-context\"\n\nexport const useLocation = () => {\n  const context = useLocationContext()\n\n  if (!context) {\n    throw new Error(\n      \"useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  return context.location\n}\n","export const useNavigate = () => {\n  throw new Error(\n    \"useNavigate is removed. Use import { navigate } from 'gatsby' instead\"\n  )\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useParams = () => {\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const results = match(context.basepath, location.pathname)\n\n  return results ? results.params : null\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { resolve, match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useMatch = path => {\n  if (!path) {\n    throw new Error(\n      \"useMatch(path: string) requires an argument of a string to match against\"\n    )\n  }\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const resolvedPath = resolve(path, context.baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return result\n    ? {\n        ...result.params,\n        uri: result.uri,\n        path,\n      }\n    : null\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,CAAA,GAAoBC,CAAA;IAClB;MAAMC,MAAA,EAAEC,CAAA;MAAFC,IAAA,EAAUC,CAAA;MAAVC,IAAA,EAAgBC,CAAA;MAAhBC,MAAA,EAAsBC,CAAA;MAAtBC,QAAA,EAA8BC,CAAA;MAA9BC,IAAA,EAAwCZ,CAAA;MAAxCa,QAAA,EAA8CC,CAAA;MAA9CC,IAAA,EAAwDC;IAAA,IAC5Df,CAAA,CAAOgB,QAAA;IACT;MAAIC,QAAA,EAAEC;IAAA,IAAalB,CAAA,CAAOgB,QAAA;IAO1B,QALKE,CAAA,IAAYZ,CAAA,IAAQa,CAAA,KAEvBD,CAAA,GADY,IAAAE,GAAA,CAAQd,CAAA,EACLW,QAAA,GAGV;MACLA,QAAA,EAAUI,SAAA,CAAUC,SAAA,CAAUJ,CAAA;MAC9BjB,MAAA,EAAAC,CAAA;MACAC,IAAA,EAAAC,CAAA;MACAC,IAAA,EAAAC,CAAA;MACAC,MAAA,EAAAC,CAAA;MACAC,QAAA,EAAAC,CAAA;MACAC,IAAA,EAAAZ,CAAA;MACAa,QAAA,EAAAC,CAAA;MACAC,IAAA,EAAAC,CAAA;MACAQ,KAAA,EAAOvB,CAAA,CAAOwB,OAAA,CAAQD,KAAA;MACtBE,GAAA,EAAMzB,CAAA,CAAOwB,OAAA,CAAQD,KAAA,IAASvB,CAAA,CAAOwB,OAAA,CAAQD,KAAA,CAAME,GAAA,IAAQ;IAAA,CAXtD;EAAA;EAAAZ,CAAA,GAeaA,CAACb,CAAA,EAAQE,CAAA;IAC7B,IAAAE,CAAA,GAAgB;MACZE,CAAA,GAAWP,CAAA,CAAYC,CAAA;MACvBU,CAAA,IAAgB;MACCG,CAAA,GAAGa,CAAA;IAExB,OAAO;MACL,IAAAV,SAAA;QACE,OAAOV,CACR;MAAA;MAED,IAAAqB,cAAA;QACE,OAAOjB,CACR;MAAA;MAEDkB,sBAAA;QACElB,CAAA,IAAgB,GAChBG,CAAA,EACD;MAAA;MAEDgB,OAAO3B,CAAA;QACLE,CAAA,CAAU0B,IAAA,CAAK5B,CAAA;QAEf,MAAMM,CAAA,GAAmBuB,CAAA;UACvBzB,CAAA,GAAWP,CAAA,CAAYC,CAAA,GACvBE,CAAA,CAAS;YAAEc,QAAA,EAAAV,CAAA;YAAU0B,MAAA,EAAQ;UAAA,EAArB;QAAA;QAKV,OAFAhC,CAAA,CAAOiC,gBAAA,CAAiB,YAAYzB,CAAA,GAE7B;UACLR,CAAA,CAAOkC,mBAAA,CAAoB,YAAY1B,CAAA,GACvCJ,CAAA,GAAYA,CAAA,CAAU+B,MAAA,CAAOnC,CAAA,IAAMA,CAAA,KAAOE,CAAA,CAA9B;QAAA,CAEf;MAAA;MAEDkC,SAASlC,CAAA;QAAIqB,KAAA,EAAER,CAAA;QAAFsB,OAAA,EAASlB,CAAA,IAAU;MAAA,IAAU,CAAlC;QACN,IAAkB,mBAAdjB,CAAA,EACFF,CAAA,CAAOwB,OAAA,CAAQc,EAAA,CAAGpC,CAAA,OACb;UACLa,CAAA,GAAaP,CAAA,KAAAO,CAAA;YAAOU,GAAA,EAAKc,IAAA,CAAKC,GAAA,KAAQ;UAAA;UAEtC;YACM9B,CAAA,IAAiBS,CAAA,GACnBnB,CAAA,CAAOwB,OAAA,CAAQiB,YAAA,CAAa1B,CAAA,EAAO,MAAMb,CAAA,IAEzCF,CAAA,CAAOwB,OAAA,CAAQkB,SAAA,CAAU3B,CAAA,EAAO,MAAMb,CAAA,CAIzC;UAAA,CAFC,QAAOE,CAAA;YACPJ,CAAA,CAAOgB,QAAA,CAASG,CAAA,GAAU,YAAY,UAAUjB,CAAA,CACjD;UAAA;QACF;QAEDI,CAAA,GAAWP,CAAA,CAAYC,CAAA,GACvBU,CAAA,IAAgB;QAChB,MAAMQ,CAAA,GAAa,IAAIyB,OAAA,CAAQ3C,CAAA,IAAQa,CAAA,GAAoBb,CAAA;QAE3D,OADAI,CAAA,CAAUwC,OAAA,CAAQ5C,CAAA,IAAYA,CAAA,CAAS;UAAEgB,QAAA,EAAAV,CAAA;UAAU0B,MAAA,EAAQ;QAAA,KACpDd,CACR;MAAA;IAAA,CApDI;EAAA;EAyDHH,CAAA,GAAqB8B,CAAC7C,CAAA,GAAc;IACxC,MAAME,CAAA,GAAcF,CAAA,CAAY8C,OAAA,CAAQ;MACnB1C,CAAA,GAAG;QACtBa,QAAA,EACEf,CAAA,IAAe,IAAIF,CAAA,CAAY+C,MAAA,CAAO,GAAG7C,CAAA,IAAeF,CAAA;QAC1DC,MAAA,EAAQC,CAAA,IAAe,IAAIF,CAAA,CAAY+C,MAAA,CAAO7C,CAAA,IAAe;MAAA;IAE/D,IAAII,CAAA,GAAQ;IACZ,MAAME,CAAA,GAAQ,CAACJ,CAAA;MAAAM,CAAA,GACA,CAAC;IAEhB,OAAO;MAAA,IAAAM,SAAA;QAEH,OAAOR,CAAA,CAAMF,CAAA,CACd;MAAA;MACD2B,iBAAiBjC,CAAA,EAAME,CAAA,GAJlB;MAKLgC,oBAAoBlC,CAAA,EAAME,CAAA,GALrB;MAMLsB,OAAA,EAAS;QACP,IAAAwB,QAAA;UACE,OAAOxC,CACR;QAAA;QAAA,IAAAyC,MAAA;UAEC,OACD3C,CAAA;QAAA;QACG,IAAAiB,MAAA;UACF,OAAab,CAAA,CAACJ,CAAA,CACf;QAAA;QACDoC,UAAU1C,CAAA,EAAOE,CAAA,EAAGE,CAAA;UAClB,OAAOL,CAAA,EAAUc,CAAA,GAAS,MAAMT,CAAA,CAAI8C,KAAA,CAAM;UAC1C5C,CAAA,IACAE,CAAA,CAAMsB,IAAA,CAAK;YAAEb,QAAA,EAAAlB,CAAA;YAAUE,MAAA,EAAQY,CAAA,CAAOsC,MAAA,GAAU,IAAGtC,CAAA,KAAWA;UAAA,IAC9DH,CAAA,CAAOoB,IAAA,CAAK9B,CAAA,CACb;QAAA;QACDyC,aAAazC,CAAA,EAAOE,CAAA,EAAGE,CAAA;UACrB,OAAOL,CAAA,EAAUc,CAAA,GAAS,MAAMT,CAAA,CAAI8C,KAAA,CAAM;UAC1C1C,CAAA,CAAMF,CAAA,IAAS;YAAEW,QAAA,EAAAlB,CAAA;YAAUE,MAAA,EAAAY;UAAA,GAC3BH,CAAA,CAAOJ,CAAA,IAASN,CACjB;QAAA;QACDsC,GAAGtC,CAAA;UACD,MAAcE,CAAA,GAAGI,CAAA,GAAQN,CAAA;UAErBE,CAAA,GAAW,KAAKA,CAAA,GAAWQ,CAAA,CAAOyC,MAAA,GAAS,MAI/C7C,CAAA,GAAQJ,CAAA,CACT;QAAA;MAAA;IAAA,CAnCE;EAAA;EA0CMiB,CAAA,KACK,sBAAAiC,MAAA,KAClBA,MAAA,CAAOC,QAAA,KACPD,MAAA,CAAOC,QAAA,CAASC,aAAA;EAOZpC,CAAA,GAAgBL,CAAA,CAJJM,CAAA,GAAGiC,MAAA,GAASrC,CAAA;EAAA;IAKxBqB,QAAA,EAAEmB;EAAA,IAAarC,CAAA;ACrIrB,SAASsC,EAA4BxD,CAAA,EAAMI,CAAA;EACzC,OAAIF,CAAA,CAAMuD,mBAAA,GAhBgB,EAACzD,CAAA,EAAMI,CAAA,GAAe,UAC3CsD,UAAA,CAAWC,gBAAA,KACdD,UAAA,CAAWC,gBAAA,GAAmB,KAG3BD,UAAA,CAAWC,gBAAA,CAAiB3D,CAAA,MAC/B0D,UAAA,CAAWC,gBAAA,CAAiB3D,CAAA,IAAQE,CAAA,CAAMuD,mBAAA,CACxCzD,CAAA,EACAI,CAAA,IAIGsD,UAAA,CAAWC,gBAAA,CAAiB3D,CAAA,IAKNA,CAAA,EAAMI,CAAA,IAGvBF,CAAA,CAAC0D,aAAA,CAAcxD,CAAA,CAC5B;AAAA;AAEY,MAAWyD,CAAA,GAAGL,CAAA,CAA4B,QAAQ;IAC7DM,OAAA,EAAS;IACTC,QAAA,EAAU;EAAA;EAECC,CAAA,GAAkBR,CAAA,CAA4B;EAAAS,CAAA,GC5B7BA,CAAA,KAAMjE,CAAA,CAAMkE,UAAA,CAAWL,CAAA;EACtBM,CAAA,GAAGC,CAAA,KAAMpE,CAAA,CAAMkE,UAAA,CAAWF,CAAA;ACEzD,SAAAK,EAAyBrE,CAAA;EACvB,KAAKsE,GAAA,GAAMtE,CACZ;AAAA;AAEK,MAAAuE,CAAA,GAAavE,CAAA,IAAKA,CAAA,YAAxBqE,CAAA;EAEMG,CAAA,GAAaxE,CAAA;IACjB,UAAMqE,CAAA,CAAoBrE,CAAA,CAApB;EAAA;AAGR,SAAAyE,EAAsBvE,CAAA;EACpB;IAAMwE,EAAA,EAAEtE,CAAA;IAAFiC,OAAA,EAAM/B,CAAA,IAAU;IAAhBiB,KAAA,EAAsBf,CAAA;IAAtBmE,OAAA,EAA6BjE,CAAA;IAA7BoD,OAAA,EAAsC/D;EAAA,IAAYG,CAAA;EAExDF,CAAA,CAAM4E,SAAA,CAAU;IACdjC,OAAA,CAAQkC,OAAA,GAAUC,IAAA,CAAK;MACrB,MAAM9E,CAAA,GAAa+E,CAAA,CAAQ3E,CAAA,EAAIL,CAAA;MAC/BwD,CAAA,CAASyB,CAAA,CAAahF,CAAA,EAAYE,CAAA,GAAQ;QAAEmC,OAAA,EAAA/B,CAAA;QAASiB,KAAA,EAAAf;MAAA,EAA7C;IAAA,EAEX;EAAA,GAAE;EAEH,MAAgBK,CAAA,GAAGkE,CAAA,CAAQ3E,CAAA,EAAIL,CAAA;EAM/B,OAJKW,CAAA,IACH8D,CAAA,CAAWQ,CAAA,CAAanE,CAAA,EAAYX,CAAA,QAIvC;AAAA;AAEK,MAAQ+E,CAAA,GAAG/E,CAAA;EACf,MAAME,CAAA,GAAkB+D,CAAA;IAAA;MAClBL,OAAA,EAAExD;IAAA,IAAY2D,CAAA;EAEpB,OAAOjE,CAAA,CAAAsD,aAAA,CAACmB,CAAA,EAADjE,CAAA,KAAkBJ,CAAA,EAAlB;IAAmC0D,OAAA,EAASxD;EAAA,GAAaJ,CAAA,EACjE;AAAA;AAED+E,CAAA,CAASC,SAAA,GAAY;EACnBC,IAAA,EAAM/E,CAAA,CAAUgF,MAAA;EAChBV,EAAA,EAAItE,CAAA,CAAUgF,MAAA,CAAOC;AAAA;ACrCjB,MAAAC,CAAA,GAAaC,CAACvF,CAAA,EAAQE,CAAA,KAAAF,CAAA,CACZ+C,MAAA,CAAO,GAAG7C,CAAA,CAAOiD,MAAA,MAAYjD,CAAA;EAAAsF,CAAA,GAyBhCvF,CAACD,CAAA,EAAQE,CAAA;IACpB,IAAAE,CAAA,EACAI,CAAA;IAEA,OAAOE,CAAA,IAAeR,CAAA,CAAIgD,KAAA,CAAM;MAC1BnD,CAAA,GAAc0F,CAAA,CAAW/E,CAAA;MAChBG,CAAA,GAAsB,OAAnBd,CAAA,CAAY;MACxBgB,CAAA,GAAS2E,CAAA,CAAW1F,CAAA;IAE1B,KAAK,IAAAA,CAAA,GAAQ,GAAGU,CAAA,GAAIK,CAAA,CAAOoC,MAAA,EAAQnD,CAAA,GAAIU,CAAA,EAAGV,CAAA,IAAK;MAC7C,IAAAU,CAAA,IAAa;MACb,MAAMS,CAAA,GAAQJ,CAAA,CAAOf,CAAA,EAAG2F,KAAA;MAExB,IAAIxE,CAAA,CAAMyE,OAAA,EAAS;QACjBpF,CAAA,GAAW;UACTmF,KAAA,EAAAxE,CAAA;UACA0E,MAAA,EAAQ;UACRvB,GAAA,EAAApE;QAAA;QAEF;MACD;MAED,MAAmBgB,CAAA,GAAGuE,CAAA,CAAWtE,CAAA,CAAM2E,IAAA;QAAAvC,CAAA,GACxB;QACTC,CAAA,GAAMuC,IAAA,CAAKC,GAAA,CAAIjG,CAAA,CAAYoD,MAAA,EAAQjC,CAAA,CAAciC,MAAA;MACvD,IAASU,CAAA,GAAG;MAEZ,OAAOA,CAAA,GAAQL,CAAA,EAAKK,CAAA,IAAS;QAC3B,MAAkB7D,CAAA,GAAGkB,CAAA,CAAc2C,CAAA;UACnB3D,CAAA,GAAGH,CAAA,CAAY8D,CAAA;QAE/B,IAAIoC,CAAA,CAAQjG,CAAA,GAAe;UAKzBuD,CAAA,CADcvD,CAAA,CAAakG,KAAA,CAAM,MAAM,OACvBnG,CAAA,CACbmG,KAAA,CAAMrC,CAAA,EACNsC,GAAA,CAAIC,kBAAA,EACJC,IAAA,CAAK;UACR;QACD;QAED,SAAmB,MAAfnG,CAAA,EAA0B;UAI5BQ,CAAA,IAAS;UACT;QACD;QAED,MAAkBN,CAAA,GAAGkG,CAAA,CAAQC,IAAA,CAAKvG,CAAA;QAElC,IAAII,CAAA,KAAiBS,CAAA,EAAW;UAC9B,MAAwBb,CAAA,IAA+C,MAA5CwG,CAAA,CAAc1D,OAAA,CAAQ1C,CAAA,CAAa;UAC9DE,CAAA,CACEN,CAAA,EACC,6BAA4BI,CAAA,CAAa,gEAAgEe,CAAA,CAAM2E,IAAA;UAElH,MAAWtF,CAAA,GAAG4F,kBAAA,CAAmBlG,CAAA;UACjCqD,CAAA,CAAOnD,CAAA,CAAa,MAAMI,CAC3B;QAAA,WAAUR,CAAA,KAAiBE,CAAA,EAAY;UAItCQ,CAAA,IAAS;UACT;QACD;MACF;MAED,KAAKA,CAAA,EAAQ;QACXN,CAAA,GAAQ;UACNuF,KAAA,EAAAxE,CAAA;UACA0E,MAAA,EAAAtC,CAAA;UACAe,GAAA,EAAK,MAAMvE,CAAA,CAAYmG,KAAA,CAAM,GAAGrC,CAAA,EAAOwC,IAAA,CAAK;QAAA;QAE9C;MACD;IACF;IAED,OAAYjG,CAAA,IAAII,CAAA,IAAY;EAAA;EAMnBiG,CAAA,GAAGC,CAAC1G,CAAA,EAAME,CAAA,KAAQsF,CAAA,CAAK,CAAC;IAAEM,IAAA,EAAA9F;EAAA,IAASE,CAAA;EAAA6E,CAAA,GA6B9BT,CAACtE,CAAA,EAAIE,CAAA;IAEnB,IAAIoF,CAAA,CAAWtF,CAAA,EAAI,MACjB,OAAOA,CAAA;IAGT,OAAOI,CAAA,EAAYE,CAAA,IAAWN,CAAA,CAAGkD,KAAA,CAAM;MAAA,CAChC1C,CAAA,IAAgBN,CAAA,CAAKgD,KAAA,CAAM;MAAAxC,CAAA,GAEf+E,CAAA,CAAWrF,CAAA;MAAAL,CAAA,GACT0F,CAAA,CAAWjF,CAAA;IAGhC,IAAsB,OAAlBE,CAAA,CAAW,IACb,OAAeiG,CAAA,CAACnG,CAAA,EAAcF,CAAA;IAIhC,KAAKgF,CAAA,CAAW5E,CAAA,CAAW,IAAI,MAAM;MACnC,MAAcV,CAAA,GAAGD,CAAA,CAAa6G,MAAA,CAAOlG,CAAA,EAAY2F,IAAA,CAAK;MACtD,OAAOM,CAAA,EAA2B,QAAjBnG,CAAA,GAAuB,KAAK,OAAOR,CAAA,EAAUM,CAAA,CAC/D;IAAA;IAOD,MAAMO,CAAA,GAAcd,CAAA,CAAa6G,MAAA,CAAOlG,CAAA;MAAAK,CAAA,GACvB;IACjB,KAAK,IAAKf,CAAA,GAAG,GAAGE,CAAA,GAAIW,CAAA,CAAYsC,MAAA,EAAQnD,CAAA,GAAIE,CAAA,EAAGF,CAAA,IAAK;MAClD,MAAAE,CAAA,GAAgBW,CAAA,CAAYb,CAAA;MACZ,SAAZE,CAAA,GAAkBa,CAAA,CAAS8F,GAAA,KACV,QAAZ3G,CAAA,IAAiBa,CAAA,CAASe,IAAA,CAAK5B,CAAA,CACzC;IAAA;IAED,OAAOyG,CAAA,CAAS,MAAM5F,CAAA,CAASsF,IAAA,CAAK,MAAM/F,CAAA,CAA3B;EAAA;EAAA0E,CAAA,GAGIA,CAAChF,CAAA,EAAME,CAAA;IAC1B,OAAOE,CAAA,EAAUE,CAAA,GAAQ,MAAMN,CAAA,CAAKkD,KAAA,CAAM;IAE1C,IAAmB1C,CAAA,GACjB,MAFeiF,CAAA,CAAWrF,CAAA,EAIvB+F,GAAA,CAAInG,CAAA;MACH,MAAWI,CAAA,GAAGkG,CAAA,CAAQC,IAAA,CAAKvG,CAAA;MAC3B,OAAAI,CAAA,GAAeF,CAAA,CAAOE,CAAA,CAAM,MAAMJ,CAAA;IAAA,GAEnCqG,IAAA,CAAK;IACV;QAAQrF,QAAA;UAAUf,MAAA,EAAES,CAAA,GAAS;QAAA,IAAO;MAAA,IAAOR,CAAA;MAC1BH,CAAA,GAAGW,CAAA,CAAOwC,KAAA,CAAM,KAAK,MAAM;IAE5C,OADA1C,CAAA,GAAkBmG,CAAA,CAASnG,CAAA,EAAiBF,CAAA,EAAOP,CAAA,GAC5CS,CAAA;EAAA;EAAAsG,CAAA,GAGgBC,CAAC/G,CAAA,EAAME,CAAA;IAC9B,MAAYE,CAAA,GAAGJ,CAAA,IAAWgH,CAAA,CAAUhH,CAAA;IAGpC,OAFmByF,CAAA,CAAWzF,CAAA,EAAMmC,MAAA,CAAO/B,CAAA,EAAQ6G,IAAA,GAAOZ,IAAA,CAAK,SAC9CZ,CAAA,CAAWvF,CAAA,EAAIiC,MAAA,CAAO/B,CAAA,EAAQ6G,IAAA,GAAOZ,IAAA,CAAK,IACrC;EAAA;EAAAC,CAAA,GAGR;EASVU,CAAA,GAAYhH,CAAA,IAAWsG,CAAA,CAAQY,IAAA,CAAKlH,CAAA;EAC7BiG,CAAA,GAAGjG,CAAA,IAAWA,CAAA,IAA0B,QAAfA,CAAA,CAAQ;EAAAmH,CAAA,GAE5BA,CAACnH,CAAA,EAAOE,CAAA,MAWjB;IAAEyF,KAAA,EAAA3F,CAAA;IAAOoH,KAAA,EAVFpH,CAAA,CAAM4F,OAAA,GAChB,IACAH,CAAA,CAAWzF,CAAA,CAAM8F,IAAA,EAAMuB,MAAA,CAAO,CAACrH,CAAA,EAAOE,CAAA,MACpCF,CAAA,IAde,GAMD,CAAAA,CAAA,IAAuB,OAAZA,CAAA,EASPE,CAAA,IAAUF,CAAA,IAXhB,IAYHgH,CAAA,CAAU9G,CAAA,IAAUF,CAAA,IAdd,IAeNiG,CAAA,CAAQ/F,CAAA,IAAUF,CAAA,IAAS,IAC1BA,CAAA,IAjBI,GAmBfA,CAAA,GAAE;IACgBiD,KAAA,EAAA/C;EAAA;EAAAwF,CAAA,GAGN1F,CAAA,IACjBA,CAAA,CACGmG,GAAA,CAAIgB,CAAA,EACJF,IAAA,CAAK,CAACjH,CAAA,EAAGE,CAAA,KACRF,CAAA,CAAEoH,KAAA,GAAQlH,CAAA,CAAEkH,KAAA,GAAQ,IAAIpH,CAAA,CAAEoH,KAAA,GAAQlH,CAAA,CAAEkH,KAAA,IAAS,IAAIpH,CAAA,CAAEiD,KAAA,GAAQ/C,CAAA,CAAE+C,KAAA;EAAAwC,CAAA,GAGhDzF,CAAA,IACjBA,CAAA,CAEGqC,OAAA,CAAQ,gBAAgB,IACxBa,KAAA,CAAM;EAELyD,CAAA,GAAWW,CAACtH,CAAA,KAAaE,CAAA,KAAAF,CAAA,KAC7BE,CAAA,GAAQA,CAAA,CAAMiC,MAAA,CAAOnC,CAAA,IAAKA,CAAA,IAAKA,CAAA,CAAEmD,MAAA,GAAS,OACdjD,CAAA,CAAMiD,MAAA,GAAS,IAAK,IAAGjD,CAAA,CAAMmG,IAAA,CAAK,SAAS;EAGnEG,CAAA,GAAgB,CAAC,OAAO;EAAAe,CAAA,GAOPA,CAACvH,CAAA,EAAME,CAAA;IAC5B,MAAAE,CAAA,GAAiBoH,MAAA,CAAOC,IAAA,CAAKzH,CAAA;IAC7B,OACEI,CAAA,CAAS+C,MAAA,KAAWqE,MAAA,CAAOC,IAAA,CAAKvH,CAAA,EAAMiD,MAAA,IACtC/C,CAAA,CAASsH,KAAA,CAAMtH,CAAA,IAAOF,CAAA,CAAKyH,cAAA,CAAevH,CAAA,KAAQJ,CAAA,CAAKI,CAAA,MAASF,CAAA,CAAKE,CAAA,EAArE;EAAA;EAIEwH,CAAA,GAAe5H,CAAA,IAAOA,CAAA,CAAIqC,OAAA,CAAQ,gBAAgB;EAElDwF,CAAA,GAAc3H,CAAA,IAAYE,CAAA;IAC9B,KAAKA,CAAA,EACH,OAAO;IAGT,IAAIA,CAAA,CAAQ0H,IAAA,KAAS9H,CAAA,CAAM+H,QAAA,IAAY3H,CAAA,CAAQ4H,KAAA,CAAMC,QAAA,EACnD,OAAAjI,CAAA,CAAakI,QAAA,CAAS/B,GAAA,CAAI/F,CAAA,CAAQ4H,KAAA,CAAMC,QAAA,EAAUJ,CAAA,CAAY3H,CAAA;IAoBhE,IAlBAI,CAAA,CACEF,CAAA,CAAQ4H,KAAA,CAAMlC,IAAA,IAAQ1F,CAAA,CAAQ4H,KAAA,CAAMpC,OAAA,IAAWxF,CAAA,CAAQ0H,IAAA,KAAS7C,CAAA,EAC/D,iIAAgI7E,CAAA,CAAQ0H,IAAA,OAG3IxH,CAAA,IACIF,CAAA,CAAQ0H,IAAA,KAAS7C,CAAA,IAAc7E,CAAA,CAAQ4H,KAAA,CAAM7C,IAAA,IAAS/E,CAAA,CAAQ4H,KAAA,CAAMtD,EAAA,GACrE,mBAAkBtE,CAAA,CAAQ4H,KAAA,CAAM7C,IAAA,SAAa/E,CAAA,CAAQ4H,KAAA,CAAMtD,EAAA,oEAG9DpE,CAAA,GAEIF,CAAA,CAAQ0H,IAAA,KAAS7C,CAAA,KAChB6B,CAAA,CAAiB1G,CAAA,CAAQ4H,KAAA,CAAM7C,IAAA,EAAM/E,CAAA,CAAQ4H,KAAA,CAAMtD,EAAA,IAErD,mBAAkBtE,CAAA,CAAQ4H,KAAA,CAAM7C,IAAA,QAAY/E,CAAA,CAAQ4H,KAAA,CAAMtD,EAAA,iGAGzDtE,CAAA,CAAQ4H,KAAA,CAAMpC,OAAA,EAChB,OAAO;MAAEuC,KAAA,EAAO/H,CAAA;MAASwF,OAAA,GAAS;IAAA;IAGpC,MAAApF,CAAA,GACEJ,CAAA,CAAQ0H,IAAA,KAAS7C,CAAA,GAAW7E,CAAA,CAAQ4H,KAAA,CAAM7C,IAAA,GAAO/E,CAAA,CAAQ4H,KAAA,CAAMlC,IAAA;MAE3DpF,CAAA,GACY,QAAhBF,CAAA,GACIN,CAAA,GACC,GAAE0H,CAAA,CAAa1H,CAAA,KAAa0H,CAAA,CAAapH,CAAA;IAEhD,OAAO;MACL2H,KAAA,EAAO/H,CAAA;MACPwF,OAAA,EAASxF,CAAA,CAAQ4H,KAAA,CAAMpC,OAAA;MACvBE,IAAA,EAAM1F,CAAA,CAAQ4H,KAAA,CAAMC,QAAA,GAAY,GAAEL,CAAA,CAAalH,CAAA,QAAYA;IAAA,CAHtD;EAAA;ECrTT0H,CAAA;EAAAC,CAAA;EAAAC,CAAA;AAMA;EAAIC,UAAA,EAAEC;AAAA,IAAexI,CAAA;AAAA,KAEK,MAAfwI,CAAA,KACTA,CAAA,GAAaxI,CAAA,IAAKA,CAAA;AAGpB,MAAOyI,CAAA,GAAG1D,CAAA;EAEG2D,CAAA,GAAOF,CAAA,CAAW,CAAyBtI,CAAA,EAAAE,CAAA;IAAQ;QAAhCuI,QAAA,EAAErI;MAAA,IAA8BJ,CAAA;MAAjBH,CAAA,GAAiBW,CAAA,CAAAR,CAAA,EAAAkI,CAAA;IAC9D;QAAMtE,OAAA,EAAEjD;MAAA,IAAYoD,CAAA;MAAA;QACdjD,QAAA,EAAED;MAAA,IAAaoD,CAAA;MAAA;QAEfO,EAAA,EAAEvD,CAAA;QAAFI,KAAA,EAAML,CAAA;QAANmB,OAAA,EAAamB,CAAA;QAAboF,QAAA,EAAsB/E,CAAA,GAAW4E;MAAA,IAAsB1I,CAAA;MAAhBiE,CAAA,GAA7CtD,CAAA,CAA6DX,CAAA,EAA7DsI,CAAA;MACMhE,CAAA,GAAOU,CAAA,CAAQ5D,CAAA,EAAIN,CAAA;MACR0D,CAAA,GAAGlD,SAAA,CAAUgD,CAAA;MACxBG,CAAA,GAAYzD,CAAA,CAASE,QAAA,KAAasD,CAAA;MAClCE,CAAA,GAAqBa,CAAA,CAAWvE,CAAA,CAASE,QAAA,EAAUsD,CAAA;IAEzD,OACEvE,CAAA,CAAAsD,aAAA,MAAA9C,CAAA;MACEqI,GAAA,EAAKzI,CAAA,IAAOE,CAAA;MACZ,gBAAckE,CAAA,GAAY,cAAS;IAAA,GAC/BR,CAAA,EACAH,CAAA,CAAS;MAAEiF,SAAA,EAAAtE,CAAA;MAAWuE,kBAAA,EAAAtE,CAAA;MAAoBpE,IAAA,EAAAgE,CAAA;MAAMrD,QAAA,EAAAD;IAAA,IAJtD;MAKEV,IAAA,EAAMgE,CAAA;MACN2E,OAAA,EAAShJ,CAAA;QAEP,IADIgE,CAAA,CAAYgF,OAAA,IAAShF,CAAA,CAAYgF,OAAA,CAAQhJ,CAAA,GD4R9B,CAAAA,CAAA,KACpBA,CAAA,CAAMiJ,gBAAA,IACU,MAAjBjJ,CAAA,CAAMkJ,MAAA,MACJlJ,CAAA,CAAMmJ,OAAA,IAAWnJ,CAAA,CAAMoJ,MAAA,IAAUpJ,CAAA,CAAMqJ,OAAA,IAAWrJ,CAAA,CAAMsJ,QAAA,GC9RjCtJ,CAAA,GAAQ;UACzBA,CAAA,CAAMuJ,cAAA;UACN,IAAIrJ,CAAA,GAAgBsD,CAAA;UACpB,IAAuB,oBAAZA,CAAA,IAAyBgB,CAAA,EAAW;YAC7C,MAAgBxE,CAAA,GAAhBU,CAAA,CAAAF,CAAA,KAAmCO,CAAA,CAASQ,KAAA,GAA5C+G,CAAA;YACApI,CAAA,GAAgBqH,CAAA,CAAoB/G,CAAA,KAAAU,CAAA,GAASlB,CAAA,CAC9C;UAAA;UACDuD,CAAA,CAASc,CAAA,EAAM;YACb9C,KAAA,EAAAL,CAAA;YACAmB,OAAA,EAASnC;UAAA,EAEZ;QAAA;MAAA;IAAA,GAnBL;EAAA;AAyBJwI,CAAA,CAAKc,WAAA,GAAc,QAEnBd,CAAA,CAAKxD,SAAA,GAAY;EACfR,EAAA,EAAItE,CAAA,CAAUgF,MAAA,CAAOC;AAAA;AClDvB,MAAAoE,CAAA,SAAiCzJ,CAAA,CAAC0J,SAAA;EAAUC,YAAA,GAAA3J,CAAA;IAAA,SAAAA,CAAA,QAC1CwJ,WAAA,GAAc,uBAD4B;EAAA;EAG1CI,kBAAA,GAAqB5J,CAAA;IAGnB,KAAK6J,QAAA,CAAS,KACd,KAAK7B,KAAA,CAAM8B,OAAA,IAAW9J,CAAA,CACvB;EAAA;EAED+J,OAAA;IACE,OAAY,KAAA/B,KAAA,CAAMC,QACnB;EAAA;AAAA;AAGH,MAE0B+B,CAAA,GAAGhK,CAAA,CAAM4D,aAAA,CAAc;EAC/CgG,iBAAA,EAAmB;IAAEK,OAAA,OAAS;EAAA;EAC9BC,KAAA,OAAO;EACPC,QAAA,EALWA,CAAA,MAAM;AAAA;AAQZ,SAAAC,EAAA;EAA8BnC,QAAA,EAAE/H;AAAA;EACrC,OAAOE,CAAA,EAAOE,CAAA,IAAYN,CAAA,CAAMqK,QAAA;IAC1B7J,CAAA,GAAoBR,CAAA,CAAMsK,MAAA;IACvB5J,CAAA,GAAGV,CAAA,CAAMuK,OAAA,CAChB,OAAO;MACLX,iBAAA,EAAApJ,CAAA;MACA0J,KAAA,EAAA9J,CAAA;MACA+J,QAAA,EAAA7J;IAAA,IAEF,CAACF,CAAA;EAEH,OACEJ,CAAA,CAAAsD,aAAA,CAAC0G,CAAA,CAAqBQ,QAAA,EAAtB;IAA+BrC,KAAA,EAAOzH;EAAA,gBACpCV,CAAA,CAAAsD,aAAA,CAACmG,CAAA,EAAD;IACES,KAAA,EAAO9J,CAAA;IACP0J,OAAA,EAASA,CAAC9J,CAAA,EAAOE,CAAA;MACfI,CAAA,CAASN,CAAA,GACT,QAAAQ,CAAA,CAAkByJ,OAAA,IAAlBzJ,CAAA,CAAkByJ,OAAA,CAAUjK,CAAA,EAAOE,CAAA,CACpC;IAAA;EAAA,GAEAA,CAAA,EAIR;AAAA;AACDkK,CAAA,CAAqBZ,WAAA,GAAc;AC9CtB,MAAAiB,CAAA,GDgDG,UAAkBvK,CAAA;IAAkB,IAAAE,CAAA,EAAAE,CAAA;IAClD,SAASI,EAAkBN,CAAA;MAAA,aACzB,OACEJ,CAAA,CAACsD,aAAA,CAAA8G,CAAA,EACC,mBAAApK,CAAA,CAAAsD,aAAA,CAACpD,CAAA,EAAiBM,CAAA;QAAAiB,GAAA,EAAI;MAAA,GAAuBrB,CAAA,GAGlD;IAAA;IAKD,OAJAM,CAAA,CAAkB8I,WAAA,GAAe,qBAC0B,SAD3BpJ,CAAA,GACE,SADFE,CAAA,GAC9BJ,CAAA,CAAiBsJ,WAAA,IAAelJ,CAAA,GAAAJ,CAAA,CAAiBwK,IAAA,IAAQtK,CAAA,mBAI5DM,CAAA;EAAA,CC7D+B,CAC9B;IAAGc,OAAA,EAAAtB,CAAA,GAAUgB,CAAA;IAAe+G,QAAA,EAAA7H;EAAA;IAC1B;QAAMY,QAAA,EAAEV;MAAA,IAAaJ,CAAA;MAAA,CAEdM,CAAA,EAASE,CAAA,IAAcV,CAAA,CAAMqK,QAAA,CAAS;QAAErJ,QAAA,EAAAV;MAAA;MAAA,CACxCP,CAAA,ID0DJ,UAA0BG,CAAA;QAC/B,MAAME,CAAA,GAAMJ,CAAA,CAAMkE,UAAA,CAAW8F,CAAA;QAC7B5J,CAAA,CAAIwJ,iBAAA,CAAkBK,OAAA,QC5DJ;QD6DlB,MAAM3J,CAAA,GAAaN,CAAA,CAAM2K,WAAA,CAAY;UACnCvK,CAAA,CAAI+J,QAAA,MAAS,EAAb;QAAA,GACC;QAEH,OAAO,CAAC/J,CAAA,CAAI8J,KAAA,EAAO5J,CAAA,CACpB;MAAA,CClEmB;IAuBhB,IArBAN,CAAA,CAAM4E,SAAA,CAAU;MACd1E,CAAA,CAAQ0B,qBAAA,EAAR;IAAA,GACC,CAACpB,CAAA,CAAQQ,QAAA,IAEZhB,CAAA,CAAM4E,SAAA,CAAU;MACd,IAAI5E,CAAA,IAAc;MAClB,MAAMI,CAAA,GAAWF,CAAA,CAAQ2B,MAAA,CAAO;QAAGb,QAAA,EAAAd;MAAA;QACjCyC,OAAA,CAAQkC,OAAA,GAAUC,IAAA,CAAK;UACrB8F,qBAAA,CAAsB;YACf5K,CAAA,IACHU,CAAA,CAAW;cAAEM,QAAA,EAAAd;YAAA,EACd;UAAA;QAAA,EAJL;MAAA;MAQF,OAAO;QACLF,CAAA,IAAc,GACdI,CAAA,EACD;MAAA;IAAA,GACA,KAECL,CAAA,EAAO;MACT,KAAIwE,CAAA,CAAWxE,CAAA,GAGb,MACDA,CAAA;MAHCwD,CAAA,CAASxD,CAAA,CAAMuE,GAAA,EAAK;QAAEjC,OAAA,GAAS;MAAA,EAIlC;IAAA;IAED,OACErC,CAAA,CAAAsD,aAAA,CAACU,CAAA,CAAgBwG,QAAA,EAAjB;MAA0BrC,KAAA,EAAO3H;IAAA,GACV,qBAApBJ,CAAA,GAAiCA,CAAA,CAASI,CAAA,IAAWJ,CAAA,IAAY,KADpE;EAAA;ECvCOyK,CAAA,GAAWC,CAAA;IAAG7C,QAAA,EAAA/H;EAAA;IACzB,MAAaE,CAAA,GAAG+D,CAAA;IAEhB,OAAI/D,CAAA,GACaF,CAAA,CAACE,CAAA,iBAETJ,CAAA,CAAAsD,aAAA,CAACmH,CAAA,EAAkB,MAAAvK,CAAA,CAC3B;EAAA;ECRwB6K,CAAA,GAAGC,CAAA;IAAGC,GAAA,EAAA/K,CAAA;IAAK+H,QAAA,EAAA7H;EAAA;IACpC,MAAiBE,CAAA,GAAGJ,CAAA,CAAI4C,OAAA,CAAQ;IAEhC,IAAAtC,CAAA;MACIE,CAAA,GAAS;IAUb,OAZqBJ,CAAA,IAAe,KAMlCE,CAAA,GAAWN,CAAA,CAAIgL,SAAA,CAAU,GAAG5K,CAAA,GAC5BI,CAAA,GAASR,CAAA,CAAIgL,SAAA,CAAU5K,CAAA,KAEvBE,CAAA,GAAWN,CAAA,eAIXF,CAAA,CAACsD,aAAA,CAAAU,CAAA,CAAgBwG,QAAA,EAAjB;MACErC,KAAA,EAAO;QACLnH,QAAA,EAAU;UACRC,QAAA,EAAAT,CAAA;UACAP,MAAA,EAAAS,CAAA;UACAP,IAAA,EAfK;QAAA;MAAA;IAAA,GAmBRC,CAAA,CATH;EAAA;ECfE+K,CAAA,GAAQC,CAAA;IAAGtF,IAAA,EAAA9F,CAAA;IAAMiI,QAAA,EAAA/H;EAAA;IACrB;QAAM4D,OAAA,EAAE1D;MAAA,IAAY6D,CAAA;MAAA;QACdjD,QAAA,EAAEV;MAAA,IAAa6D,CAAA;MAEHzD,CAAA,GAAGqE,CAAA,CAAQ/E,CAAA,EAAMI,CAAA;MAAAL,CAAA,GACpB0G,CAAA,CAAM/F,CAAA,EAAcJ,CAAA,CAASW,QAAA;IAC5C,OAAAf,CAAA,CAAgB;MACdc,QAAA,EAAAV,CAAA;MACAoG,KAAA,EAAO3G,CAAA,GAAAS,CAAA,KAEET,CAAA,CAAO8F,MAAA,EACV;QAAAvB,GAAA,EAAKvE,CAAA,CAAOuE,GAAA;QACZwB,IAAA,EAAA9F;MAAA,KAEF;IAAA,EARS;EAAA;ECTjBqL,CAAA;EAAAC,CAAA;EAEaC,EAAA,GAAerL,CAAA;IAAA;QAACoE,GAAA,EAAElE,CAAA;QAAFY,QAAA,EAAOV,CAAA;QAAPkL,SAAA,EAAiBzL;MAAA,IAA6BG,CAAA;MAAfW,CAAA,GAAeH,CAAA,CAAAR,CAAA,EAAAmL,CAAA;IACzE,OACErL,CAAA,CAACsD,aAAA,CAAAmI,EAAA,EACKjL,CAAA,KAAAK,CAAA;MACJ2K,SAAA,EAAWzL,CAAA;MACXuE,GAAA,EAAKlE,CAAA;MACLY,QAAA,EAAUV;IAAA,GAGf;EAAA;AAED,IAAAoL,EAAA,GAAwB;AAExB,MAAAD,EAAA,GAAyBvL,CAAA;IAAC;QAAA+H,QAAA,EACxB7H,CAAA;QADwBuL,KAAA,EAExBrL,CAAA;QACAkL,SAAA,EAAWzL,CAAA,GAAO;QAHMuE,GAAA,EAIxBzD,CAAA;QAJwBG,QAAA,EAKxBD;MAAA,IAAAb,CAAA;MACGiB,CAAA,GACCT,CAAA,CAAAR,CAAA,EAAAoL,CAAA;IACJ,MAAqBpK,CAAA,GAAGlB,CAAA,CAAMsK,MAAA;MACR/G,CAAA,GAAGvD,CAAA,CAAMsK,MAAA,EAAO;MAC1B9G,CAAA,GAAGxD,CAAA,CAAMsK,MAAA,CAAOzJ,CAAA;MAAAgD,CAAA,GACR7D,CAAA,CAAMsK,MAAA,CAAOvJ,CAAA,CAASE,QAAA;MACpC+C,CAAA,GAAiBhE,CAAA,CAAMsK,MAAA,EAAO;IASpCtK,CAAA,CAAM4E,SAAA,CAAU,OACd8G,EAAA,IACAzH,CAAA,IAEO;MACLyH,EAAA,IAC0B,MAAtBA,EAAA,KACFnI,CAAA,CAAiB0G,OAAA,IAAU,EAC5B;IAAA,IAEF,KAGHjK,CAAA,CAAM4E,SAAA,CAAU;MACd,IAAI5E,CAAA,IAAa;QACEE,CAAA,IAAG;MAElBW,CAAA,KAAQ2C,CAAA,CAAOyG,OAAA,KACjBzG,CAAA,CAAOyG,OAAA,GAAUpJ,CAAA,EACjBb,CAAA,IAAa,IAGXe,CAAA,CAASE,QAAA,KAAa4C,CAAA,CAAYoG,OAAA,KACpCpG,CAAA,CAAYoG,OAAA,GAAUlJ,CAAA,CAASE,QAAA,EAC/Bf,CAAA,IAAkB,IAKpB8D,CAAA,CAAeiG,OAAA,GAAUjK,CAAA,IAFDE,CAAA,IAAmBa,CAAA,CAASE,QAAA,KAAaJ,CAAA,EAI7DmD,CAAA,CAAeiG,OAAA,IACjBhG,CAAA,EACD;IAAA,GACA,CAACpD,CAAA,EAAKE,CAAA;IAET,MAAAkD,CAAA,GAAcjE,CAAA,CAAM2K,WAAA,CAAY;MA3CV,IAAA3K,CAAA;MA4CS,WAAzB4L,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAMZvI,CAAA,CAAiB0G,OAAA,GACnB1G,CAAA,CAAiB0G,OAAA,IAAU,KAnDTjK,CAAA,GAqDJkB,CAAA,CAAgB+I,OAAA,EApD5BjG,CAAA,CAAeiG,OAAA,IAAWjK,CAAA,IAC5BA,CAAA,CAAY+L,KAAA,IAoDb;IAAA,GACA;IAEH,OACE/L,CAAA,CAAAsD,aAAA,CAACvD,CAAA,EACCS,CAAA;MAAAmL,KAAA,EAASnL,CAAA;QAAAwL,OAAA,EAAS;MAAA,GAAW1L,CAAA;MAC7B2L,QAAA,EAAS;MACTpD,GAAA,EAAK3H;IAAA,GACDC,CAAA,GAEHf,CAAA,CANH;EAAA;ECvFJ8L,EAAA;EAAAC,EAAA,GAMsBjM,CAAA;IACpB,MAAME,CAAA,GAAc6D,CAAA;MACC3D,CAAA,GAAG6D,CAAA;IAExB,OAAOnE,CAAA,CAAAsD,aAAA,CAAC8I,EAAA,EAAD5L,CAAA,KAAgBJ,CAAA,EAAiBE,CAAA,EAAqBJ,CAAA,EAAtD;EAAA;AAGT,SAAAkM,GAAoBlM,CAAA;EAClB;MAAMc,QAAA,EACJZ,CAAA;MADIiM,OAAA,EAEJ/L,CAAA,IAAU;MAFN2H,QAAA,EAGJlI,CAAA;MAHIgE,QAAA,EAIJlD,CAAA;MAJI2K,SAAA,EAMJzK,CAAA,GAAY;IAAA,IAEVb,CAAA;IADCiB,CAAA,GAPLT,CAAA,CAQIR,CAAA,EAEJgM,EAAA;IAAYhL,CAAA,GAAGlB,CAAA,CAAMkI,QAAA,CAASoE,OAAA,CAAQvM,CAAA,EAAUsH,MAAA,CAAO,CAACrH,CAAA,EAAOE,CAAA;MAC7D,MAAYE,CAAA,GAAGyH,CAAA,CAAYhH,CAAA,CAAZ,CAAsBX,CAAA;MACrC,OAAYF,CAAA,CAAC4G,MAAA,CAAOxG,CAAA,CAAb;IAAA,GACN;IAAA;MACGa,QAAA,EAAEsC;IAAA,IAAanD,CAAA;IAAAoD,CAAA,GACPgC,CAAA,CAAKtE,CAAA,EAAQqC,CAAA;EAE3B,IAAIC,CAAA,EAAO;IACT;QAAMqC,MAAA,EACJ3F,CAAA;QADIoE,GAAA,EAEJ5D,CAAA;QAFIiF,KAAA,EAGJ5F,CAAA;QACA4F,KAAA;UAASwC,KAAA,EAAOjH;QAAA;MAAA,IACdsC,CAAA;MAAAD,CAAA,GAGuBxD,CAAA,CAAM6F,OAAA,GAC7B/E,CAAA,GACAd,CAAA,CAAM+F,IAAA,CAAKzD,OAAA,CAAQ,OAAO;MAEnB2B,CAAA,GAAAxD,CAAA,KACNN,CAAA,EADM;QAEToE,GAAA,EAAA5D,CAAA;QACAM,QAAA,EAAAZ;MAAA;MAGI6D,CAAA,GAAQjE,CAAA,CAAMuM,YAAA,CAClBrL,CAAA,EACA8C,CAAA,EACA9C,CAAA,CAAQ8G,KAAA,CAAMC,QAAA,gBACZjI,CAAA,CAAAsD,aAAA,CAAC6I,EAAA,EAAO;QAAAnL,QAAA,EAAUZ,CAAA;QAAUiM,OAAA,EAAS/L;MAAA,GAClCY,CAAA,CAAQ8G,KAAA,CAAMC,QAAA,SAEf;MAIY9D,CAAA,GAAG7D,CAAA,GAAUiL,EAAA,GAAexK,CAAA;MAE5BsD,CAAA,GAAG/D,CAAA,GACfE,CAAA;QAAA8D,GAAA,EAAA5D,CAAA;QAAKM,QAAA,EAAAZ,CAAA;QAAUoL,SAAA,EAAAzK;MAAA,GAAcI,CAAA,IAC/BA,CAAA;IAEJ,OACEnB,CAAA,CAAAsD,aAAA,CAACO,CAAA,CAAY2G,QAAA,EACX;MAAArC,KAAA,EAAO;QAAErE,OAAA,EAASpD,CAAA;QAAKqD,QAAA,EAAUR;MAAA;IAAA,gBAEjCvD,CAAA,CAACsD,aAAA,CAAAa,CAAA,EAAiBE,CAAA,EAAeJ,CAAA,EAGtC;EAAA;EACC,WAEH;AAAA;AC3EY,MAAAuI,EAAA,GAAcC,CAAA;IACzB,MAAazM,CAAA,GAAGmE,CAAA;IAEhB,KAAKnE,CAAA,EACH,UAAM0M,KAAA,CACJ;IAIJ,OAAc1M,CAAA,CAACgB,QAAA;EAAA;ECXO2L,EAAA,GAAGC,CAAA;IACzB,MAAM,IAAAF,KAAA,CACJ,wEADI;EAAA;ECGKG,EAAA,GAAYC,CAAA;IACvB,MAAA9M,CAAA,GAAgBiE,CAAA;IAEhB,KAAKjE,CAAA,EACH,MAAM,IAAA0M,KAAA,CACJ;IAIJ,MAAcxM,CAAA,GAAGsM,EAAA;MAEJpM,CAAA,GAAGqG,CAAA,CAAMzG,CAAA,CAAQ+D,QAAA,EAAU7D,CAAA,CAASe,QAAA;IAEjD,OAAcb,CAAA,GAAGA,CAAA,CAAQyF,MAAA,GAAS;EAAA;ECbvBkH,EAAA,GAAW/M,CAAA;IACtB,KAAKA,CAAA,EACH,UAAM0M,KAAA,CACJ;IAGJ,MAAAxM,CAAA,GAAgB+D,CAAA;IAEhB,KAAK/D,CAAA,EACH,MAAU,IAAAwM,KAAA,CACR;IAIJ,MAAMtM,CAAA,GAAWoM,EAAA;MAEClM,CAAA,GAAGyE,CAAA,CAAQ/E,CAAA,EAAME,CAAA,CAAQ4D,OAAA;MACrCpD,CAAA,GAAS+F,CAAA,CAAMnG,CAAA,EAAcF,CAAA,CAASa,QAAA;IAC5C,OAAaP,CAAA,GAAAF,CAAA,KAEJE,CAAA,CAAOmF,MAAA,EACV;MAAAvB,GAAA,EAAK5D,CAAA,CAAO4D,GAAA;MACZwB,IAAA,EAAA9F;IAAA,KAEF;EAAA;AAAA,SAAA6D,CAAA,IAAAmJ,WAAA,EAAAtE,CAAA,IAAAuE,IAAA,EAAApC,CAAA,IAAAC,QAAA,EAAA9G,CAAA,IAAAkJ,eAAA,EAAAzC,CAAA,IAAA0C,gBAAA,EAAAhC,CAAA,IAAAC,KAAA,EAAAnG,CAAA,IAAAmI,QAAA,EAAAjB,EAAA,IAAAkB,MAAA,EAAAtC,CAAA,IAAAC,cAAA,EAAAnK,CAAA,IAAAyM,aAAA,EAAAvM,CAAA,IAAA8B,kBAAA,EAAA3B,CAAA,IAAAqM,aAAA,EAAAvI,CAAA,IAAAwI,YAAA,EAAAjJ,CAAA,IAAAkJ,UAAA,EAAAhH,CAAA,IAAAC,KAAA,EAAAnD,CAAA,IAAAnB,QAAA,EAAAoD,CAAA,IAAAkI,IAAA,EAAAlJ,CAAA,IAAAmJ,UAAA,EAAA5I,CAAA,IAAAF,OAAA,EAAA0C,CAAA,IAAAqG,cAAA,EAAAtI,CAAA,IAAAC,UAAA,EAAAtB,CAAA,IAAA4J,cAAA,EAAArB,EAAA,IAAAC,WAAA,EAAAtI,CAAA,IAAAC,kBAAA,EAAA2I,EAAA,IAAAe,QAAA,EAAAnB,EAAA,IAAAC,WAAA,EAAAC,EAAA,IAAAC,SAAA,EAAAhG,CAAA,IAAAiH,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}