{"ast":null,"code":"import axios from \"axios\";\nconst axiosInstance = axios.create({\n  baseURL: \"http://localhost:4000\"\n});\naxiosInstance.interceptors.request.use(async config => {\n  const token = localStorage.getItem(\"token\");\n  console.log(\"ttttt\", token);\n  const refreshToken = localStorage.getItem(\"refreshToken\");\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  if (refreshToken) {\n    config.headers[\"refresh-token\"] = refreshToken;\n  }\n  console.log(\"Request Interceptor:\", config);\n  return config;\n}, error => {\n  console.error(\"Request Interceptor Error:\", error);\n  return Promise.reject(error);\n});\naxiosInstance.interceptors.response.use(async response => {\n  console.log(\"Response Interceptor:\", response);\n  console.log(\"Response Headers:\", response.headers);\n  if (response.data.token) {\n    const newtoken = response.data.token;\n\n    // Update the local storage with the new access token\n    localStorage.setItem(\"token\", newtoken);\n  }\n  return response;\n}, async error => {\n  console.error(\"Response Interceptor Error:\", error);\n  if (error.response && error.response.status === 419) {\n    // Handle 419 error by refreshing the token\n    try {\n      const refreshToken = localStorage.getItem(\"refreshToken\");\n      if (!refreshToken) {\n        throw new Error(\"No refresh token available\");\n      }\n      console.log(\"Inside token expiration handler, refreshing token...\");\n      const refreshResponse = await axios.get(`http://localhost:4000/`, {\n        headers: {\n          \"refresh-token\": refreshToken\n        }\n      });\n      console.log(\"-----------------resrefresh\", refreshResponse);\n      const newtoken = refreshResponse.data.token;\n      console.log(\"new token\", newtoken);\n      localStorage.setItem(\"token\", newtoken);\n\n      // Retry the original request with the new access token\n      const originalRequest = error.config;\n      originalRequest.headers.Authorization = `Bearer ${newtoken}`;\n      return axiosInstance(originalRequest);\n    } catch (refreshError) {\n      console.error(\"Error refreshing access token:\", refreshError);\n\n      // If the refresh token has expired, dispatch logout action\n      if (refreshError.response.status === 401 && refreshError.response.data.message === \"Refresh token has expired\") return Promise.reject(error);\n    }\n  }\n  return Promise.reject(error);\n});\nexport default axiosInstance;","map":{"version":3,"names":["axios","axiosInstance","create","baseURL","interceptors","request","use","config","token","localStorage","getItem","console","log","refreshToken","headers","Authorization","error","Promise","reject","response","data","newtoken","setItem","status","Error","refreshResponse","get","originalRequest","refreshError","message"],"sources":["/home/rhydham/Documents/Tetime/frontend/src/Axios/axios.js"],"sourcesContent":["import axios from \"axios\";\nconst axiosInstance = axios.create({baseURL: \"http://localhost:4000\"}); \n \naxiosInstance.interceptors.request.use(\n  async (config) => {\n    const token = localStorage.getItem(\"token\");\n    console.log(\"ttttt\",token);\n    const refreshToken = localStorage.getItem(\"refreshToken\");\n\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n\n    if (refreshToken) {\n      config.headers[\"refresh-token\"] = refreshToken;\n    }\n\n    console.log(\"Request Interceptor:\", config);\n    return config;\n  },\n  (error) => {\n    console.error(\"Request Interceptor Error:\", error);\n    return Promise.reject(error);\n  }\n);\n\naxiosInstance.interceptors.response.use(\n  async (response) => {\n    console.log(\"Response Interceptor:\", response);\n    console.log(\"Response Headers:\", response.headers);\n\n    if (response.data.token) {\n      const newtoken = response.data.token;\n\n      // Update the local storage with the new access token\n      localStorage.setItem(\"token\", newtoken);\n    }\n\n    return response;\n  },\n  async (error) => {\n    console.error(\"Response Interceptor Error:\", error);\n\n    if (error.response && error.response.status === 419) {\n      // Handle 419 error by refreshing the token\n      try {\n        const refreshToken = localStorage.getItem(\"refreshToken\");\n        if (!refreshToken) {\n          throw new Error(\"No refresh token available\");\n        }\n\n        console.log(\"Inside token expiration handler, refreshing token...\");\n        const refreshResponse = await axios.get(\n          `http://localhost:4000/`,\n          {\n            headers: {\n              \"refresh-token\": refreshToken,\n            },\n          }\n        );\n        console.log(\"-----------------resrefresh\", refreshResponse);\n\n        const newtoken = refreshResponse.data.token;\n        console.log(\"new token\", newtoken);\n        localStorage.setItem(\"token\", newtoken);\n\n        // Retry the original request with the new access token\n        const originalRequest = error.config;\n        originalRequest.headers.Authorization = `Bearer ${newtoken}`;\n        return axiosInstance(originalRequest);\n      } catch (refreshError) {\n        console.error(\"Error refreshing access token:\", refreshError);\n\n        // If the refresh token has expired, dispatch logout action\n        if (\n          refreshError.response.status === 401 &&\n          refreshError.response.data.message === \"Refresh token has expired\"\n        )\n        \n        return Promise.reject(error);\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n\n\n \nexport default axiosInstance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}