{"ast":null,"code":"\"use client\";\n\nimport t from \"prop-types\";\nimport e from \"react\";\nimport { resolve as n, Location as r, Link as o } from \"@gatsbyjs/reach-router\";\nimport { applyTrailingSlashOption as s } from \"gatsby-page-utils/apply-trailing-slash-option\";\nfunction i() {\n  return i = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n    return t;\n  }, i.apply(this, arguments);\n}\nfunction a(t) {\n  let e = t || \"/\",\n    n = \"\",\n    r = \"\";\n  const o = e.indexOf(\"#\");\n  -1 !== o && (r = e.slice(o), e = e.slice(0, o));\n  const s = e.indexOf(\"?\");\n  return -1 !== s && (n = e.slice(s), e = e.slice(0, s)), {\n    pathname: e,\n    search: \"?\" === n ? \"\" : n,\n    hash: \"#\" === r ? \"\" : r\n  };\n}\nconst c = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/,\n  l = t => {\n    if (\"string\" == typeof t) return !(t => c.test(t))(t);\n  },\n  p = () => \"production\" !== process.env.NODE_ENV ? \"undefined\" != typeof __BASE_PATH__ ? __BASE_PATH__ : void 0 : __BASE_PATH__,\n  h = () => \"production\" !== process.env.NODE_ENV ? \"undefined\" != typeof __PATH_PREFIX__ ? __PATH_PREFIX__ : void 0 : __PATH_PREFIX__;\nfunction f(t, e = p()) {\n  var n;\n  if (!l(t)) return t;\n  if (t.startsWith(\"./\") || t.startsWith(\"../\")) return t;\n  const r = null != (n = null != e ? e : h()) ? n : \"/\";\n  return `${null != r && r.endsWith(\"/\") ? r.slice(0, -1) : r}${t.startsWith(\"/\") ? t : `/${t}`}`;\n}\nconst u = t => null == t ? void 0 : t.startsWith(\"/\"),\n  _ = () => \"undefined\" != typeof __TRAILING_SLASH__ ? __TRAILING_SLASH__ : void 0;\nfunction d(t, e) {\n  const {\n    pathname: n,\n    search: r,\n    hash: o\n  } = a(t);\n  return `${s(n, e)}${r}${o}`;\n}\nconst m = (t, e) => \"number\" == typeof t ? t : l(t) ? u(t) ? function (t) {\n    const e = f(t),\n      n = _();\n    return \"always\" === n || \"never\" === n ? d(e, n) : e;\n  }(t) : function (t, e) {\n    if (u(t)) return t;\n    const r = _(),\n      o = n(t, e);\n    return \"always\" === r || \"never\" === r ? d(o, r) : o;\n  }(t, e) : t,\n  y = [\"to\", \"getProps\", \"onClick\", \"onMouseEnter\", \"activeClassName\", \"activeStyle\", \"innerRef\", \"partiallyActive\", \"state\", \"replace\", \"_location\"];\nfunction v(t) {\n  return f(t, h());\n}\nconst b = {\n  activeClassName: t.string,\n  activeStyle: t.object,\n  partiallyActive: t.bool\n};\nfunction w(t) {\n  /*#__PURE__*/return e.createElement(r, null, ({\n    location: n\n  }) => /*#__PURE__*/e.createElement(P, i({}, t, {\n    _location: n\n  })));\n}\nclass P extends e.Component {\n  constructor(t) {\n    super(t), this.defaultGetProps = ({\n      isPartiallyCurrent: t,\n      isCurrent: e\n    }) => (this.props.partiallyActive ? t : e) ? {\n      className: [this.props.className, this.props.activeClassName].filter(Boolean).join(\" \"),\n      style: i({}, this.props.style, this.props.activeStyle)\n    } : null;\n    let e = !1;\n    \"undefined\" != typeof window && window.IntersectionObserver && (e = !0), this.state = {\n      IOSupported: e\n    }, this.abortPrefetch = null, this.handleRef = this.handleRef.bind(this);\n  }\n  _prefetch() {\n    let t = window.location.pathname + window.location.search;\n    this.props._location && this.props._location.pathname && (t = this.props._location.pathname + this.props._location.search);\n    const e = a(m(this.props.to, t)),\n      n = e.pathname + e.search;\n    if (t !== n) return ___loader.enqueue(n);\n  }\n  componentWillUnmount() {\n    if (!this.io) return;\n    const {\n      instance: t,\n      el: e\n    } = this.io;\n    this.abortPrefetch && this.abortPrefetch.abort(), t.unobserve(e), t.disconnect();\n  }\n  handleRef(t) {\n    this.props.innerRef && Object.prototype.hasOwnProperty.call(this.props.innerRef, \"current\") ? this.props.innerRef.current = t : this.props.innerRef && this.props.innerRef(t), this.state.IOSupported && t && (this.io = ((t, e) => {\n      const n = new window.IntersectionObserver(n => {\n        n.forEach(n => {\n          t === n.target && e(n.isIntersecting || n.intersectionRatio > 0);\n        });\n      });\n      return n.observe(t), {\n        instance: n,\n        el: t\n      };\n    })(t, t => {\n      t ? this.abortPrefetch = this._prefetch() : this.abortPrefetch && this.abortPrefetch.abort();\n    }));\n  }\n  render() {\n    const t = this.props,\n      {\n        to: n,\n        getProps: r = this.defaultGetProps,\n        onClick: s,\n        onMouseEnter: c,\n        state: p,\n        replace: h,\n        _location: f\n      } = t,\n      u = function (t, e) {\n        if (null == t) return {};\n        var n,\n          r,\n          o = {},\n          s = Object.keys(t);\n        for (r = 0; r < s.length; r++) e.indexOf(n = s[r]) >= 0 || (o[n] = t[n]);\n        return o;\n      }(t, y);\n    \"production\" === process.env.NODE_ENV || l(n) || console.warn(`External link ${n} was detected in a Link component. Use the Link component only for internal links. See: https://gatsby.dev/internal-links`);\n    const _ = m(n, f.pathname);\n    return l(_) ? /*#__PURE__*/e.createElement(o, i({\n      to: _,\n      state: p,\n      getProps: r,\n      innerRef: this.handleRef,\n      onMouseEnter: t => {\n        c && c(t);\n        const e = a(_);\n        ___loader.hovering(e.pathname + e.search);\n      },\n      onClick: t => {\n        if (s && s(t), !(0 !== t.button || this.props.target || t.defaultPrevented || t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)) {\n          t.preventDefault();\n          let e = h;\n          const n = encodeURI(_) === f.pathname;\n          \"boolean\" != typeof h && n && (e = !0), window.___navigate(_, {\n            state: p,\n            replace: e\n          });\n        }\n        return !0;\n      }\n    }, u)) : /*#__PURE__*/e.createElement(\"a\", i({\n      href: _\n    }, u));\n  }\n}\nP.propTypes = i({}, b, {\n  onClick: t.func,\n  to: t.string.isRequired,\n  replace: t.bool,\n  state: t.object\n});\nconst E = e.forwardRef((t, n) => /*#__PURE__*/e.createElement(w, i({\n    innerRef: n\n  }, t))),\n  g = (t, e) => {\n    window.___navigate(m(t, window.location.pathname), e);\n  };\nexport { E as Link, g as navigate, a as parsePath, v as withAssetPrefix, f as withPrefix };","map":{"version":3,"names":[],"sources":["/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-link/src/parse-path.js","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-link/src/is-local-link.js","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-link/src/prefix-helpers.js","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-link/src/rewrite-link-path.js","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-link/src/index.js"],"sourcesContent":["export function parsePath(path) {\n  let pathname = path || `/`\n  let search = ``\n  let hash = ``\n\n  const hashIndex = pathname.indexOf(`#`)\n  if (hashIndex !== -1) {\n    hash = pathname.slice(hashIndex)\n    pathname = pathname.slice(0, hashIndex)\n  }\n\n  const searchIndex = pathname.indexOf(`?`)\n  if (searchIndex !== -1) {\n    search = pathname.slice(searchIndex)\n    pathname = pathname.slice(0, searchIndex)\n  }\n\n  return {\n    pathname: pathname,\n    search: search === `?` ? `` : search,\n    hash: hash === `#` ? `` : hash,\n  }\n}\n","// Copied from https://github.com/sindresorhus/is-absolute-url/blob/3ab19cc2e599a03ea691bcb8a4c09fa3ebb5da4f/index.js\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nconst isAbsolute = path => ABSOLUTE_URL_REGEX.test(path)\n\nexport const isLocalLink = path => {\n  if (typeof path !== `string`) {\n    return undefined\n    // TODO(v5): Re-Add TypeError\n    // throw new TypeError(`Expected a \\`string\\`, got \\`${typeof path}\\``)\n  }\n\n  return !isAbsolute(path)\n}\n","import { isLocalLink } from \"./is-local-link\"\n\nexport const getGlobalBasePrefix = () =>\n  process.env.NODE_ENV !== `production`\n    ? typeof __BASE_PATH__ !== `undefined`\n      ? __BASE_PATH__\n      : undefined\n    : __BASE_PATH__\n\n// These global values are wrapped in typeof clauses to ensure the values exist.\n// This is especially problematic in unit testing of this component.\nexport const getGlobalPathPrefix = () =>\n  process.env.NODE_ENV !== `production`\n    ? typeof __PATH_PREFIX__ !== `undefined`\n      ? __PATH_PREFIX__\n      : undefined\n    : __PATH_PREFIX__\n\nexport function withPrefix(path, prefix = getGlobalBasePrefix()) {\n  if (!isLocalLink(path)) {\n    return path\n  }\n\n  if (path.startsWith(`./`) || path.startsWith(`../`)) {\n    return path\n  }\n  const base = prefix ?? getGlobalPathPrefix() ?? `/`\n\n  return `${base?.endsWith(`/`) ? base.slice(0, -1) : base}${\n    path.startsWith(`/`) ? path : `/${path}`\n  }`\n}\n","import { resolve } from \"@gatsbyjs/reach-router\"\n// Specific import to treeshake Node.js stuff\nimport { applyTrailingSlashOption } from \"gatsby-page-utils/apply-trailing-slash-option\"\nimport { parsePath } from \"./parse-path\"\nimport { isLocalLink } from \"./is-local-link\"\nimport { withPrefix } from \"./prefix-helpers\"\n\nconst isAbsolutePath = path => path?.startsWith(`/`)\n\nconst getGlobalTrailingSlash = () =>\n  typeof __TRAILING_SLASH__ !== `undefined` ? __TRAILING_SLASH__ : undefined\n\nfunction applyTrailingSlashOptionOnPathnameOnly(path, option) {\n  const { pathname, search, hash } = parsePath(path)\n  const output = applyTrailingSlashOption(pathname, option)\n\n  return `${output}${search}${hash}`\n}\n\nfunction absolutify(path, current) {\n  // If it's already absolute, return as-is\n  if (isAbsolutePath(path)) {\n    return path\n  }\n\n  const option = getGlobalTrailingSlash()\n  const absolutePath = resolve(path, current)\n\n  if (option === `always` || option === `never`) {\n    return applyTrailingSlashOptionOnPathnameOnly(absolutePath, option)\n  }\n\n  return absolutePath\n}\n\nfunction applyPrefix(path) {\n  const prefixed = withPrefix(path)\n  const option = getGlobalTrailingSlash()\n\n  if (option === `always` || option === `never`) {\n    return applyTrailingSlashOptionOnPathnameOnly(prefixed, option)\n  }\n\n  return prefixed\n}\n\nexport const rewriteLinkPath = (path, relativeTo) => {\n  if (typeof path === `number`) {\n    return path\n  }\n  if (!isLocalLink(path)) {\n    return path\n  }\n\n  return isAbsolutePath(path) ? applyPrefix(path) : absolutify(path, relativeTo)\n}\n","import PropTypes from \"prop-types\"\nimport React from \"react\"\nimport { Link as ReachRouterLink, Location } from \"@gatsbyjs/reach-router\"\nimport { parsePath } from \"./parse-path\"\nimport { isLocalLink } from \"./is-local-link\"\nimport { rewriteLinkPath } from \"./rewrite-link-path\"\nimport { withPrefix, getGlobalPathPrefix } from \"./prefix-helpers\"\n\nexport { parsePath, withPrefix }\n\nexport function withAssetPrefix(path) {\n  return withPrefix(path, getGlobalPathPrefix())\n}\n\nconst NavLinkPropTypes = {\n  activeClassName: PropTypes.string,\n  activeStyle: PropTypes.object,\n  partiallyActive: PropTypes.bool,\n}\n\n// Set up IntersectionObserver\nconst createIntersectionObserver = (el, cb) => {\n  const io = new window.IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (el === entry.target) {\n        // Check if element is within viewport, remove listener, destroy observer, and run link callback.\n        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0\n        cb(entry.isIntersecting || entry.intersectionRatio > 0)\n      }\n    })\n  })\n\n  // Add element to the observer\n  io.observe(el)\n\n  return { instance: io, el }\n}\n\nfunction GatsbyLinkLocationWrapper(props) {\n  return (\n    <Location>\n      {({ location }) => <GatsbyLink {...props} _location={location} />}\n    </Location>\n  )\n}\n\nclass GatsbyLink extends React.Component {\n  constructor(props) {\n    super(props)\n    // Default to no support for IntersectionObserver\n    let IOSupported = false\n    if (typeof window !== `undefined` && window.IntersectionObserver) {\n      IOSupported = true\n    }\n\n    this.state = {\n      IOSupported,\n    }\n    this.abortPrefetch = null\n    this.handleRef = this.handleRef.bind(this)\n  }\n\n  _prefetch() {\n    let currentPath = window.location.pathname + window.location.search\n\n    // reach router should have the correct state\n    if (this.props._location && this.props._location.pathname) {\n      currentPath = this.props._location.pathname + this.props._location.search\n    }\n\n    const rewrittenPath = rewriteLinkPath(this.props.to, currentPath)\n    const parsed = parsePath(rewrittenPath)\n\n    const newPathName = parsed.pathname + parsed.search\n\n    // Prefetch is used to speed up next navigations. When you use it on the current navigation,\n    // there could be a race-condition where Chrome uses the stale data instead of waiting for the network to complete\n    if (currentPath !== newPathName) {\n      return ___loader.enqueue(newPathName)\n    }\n\n    return undefined\n  }\n\n  componentWillUnmount() {\n    if (!this.io) {\n      return\n    }\n    const { instance, el } = this.io\n\n    if (this.abortPrefetch) {\n      this.abortPrefetch.abort()\n    }\n\n    instance.unobserve(el)\n    instance.disconnect()\n  }\n\n  handleRef(ref) {\n    if (\n      this.props.innerRef &&\n      Object.prototype.hasOwnProperty.call(this.props.innerRef, `current`)\n    ) {\n      this.props.innerRef.current = ref\n    } else if (this.props.innerRef) {\n      this.props.innerRef(ref)\n    }\n\n    if (this.state.IOSupported && ref) {\n      // If IO supported and element reference found, setup Observer functionality\n      this.io = createIntersectionObserver(ref, inViewPort => {\n        if (inViewPort) {\n          this.abortPrefetch = this._prefetch()\n        } else {\n          if (this.abortPrefetch) {\n            this.abortPrefetch.abort()\n          }\n        }\n      })\n    }\n  }\n\n  defaultGetProps = ({ isPartiallyCurrent, isCurrent }) => {\n    if (this.props.partiallyActive ? isPartiallyCurrent : isCurrent) {\n      return {\n        className: [this.props.className, this.props.activeClassName]\n          .filter(Boolean)\n          .join(` `),\n        style: { ...this.props.style, ...this.props.activeStyle },\n      }\n    }\n    return null\n  }\n\n  render() {\n    const {\n      to,\n      getProps = this.defaultGetProps,\n      onClick,\n      onMouseEnter,\n      /* eslint-disable no-unused-vars */\n      activeClassName: $activeClassName,\n      activeStyle: $activeStyle,\n      innerRef: $innerRef,\n      partiallyActive,\n      state,\n      replace,\n      _location,\n      /* eslint-enable no-unused-vars */\n      ...rest\n    } = this.props\n\n    if (process.env.NODE_ENV !== `production` && !isLocalLink(to)) {\n      console.warn(\n        `External link ${to} was detected in a Link component. Use the Link component only for internal links. See: https://gatsby.dev/internal-links`\n      )\n    }\n\n    const prefixedTo = rewriteLinkPath(to, _location.pathname)\n    if (!isLocalLink(prefixedTo)) {\n      return <a href={prefixedTo} {...rest} />\n    }\n\n    return (\n      <ReachRouterLink\n        to={prefixedTo}\n        state={state}\n        getProps={getProps}\n        innerRef={this.handleRef}\n        onMouseEnter={e => {\n          if (onMouseEnter) {\n            onMouseEnter(e)\n          }\n          const parsed = parsePath(prefixedTo)\n          ___loader.hovering(parsed.pathname + parsed.search)\n        }}\n        onClick={e => {\n          if (onClick) {\n            onClick(e)\n          }\n\n          if (\n            e.button === 0 && // ignore right clicks\n            !this.props.target && // let browser handle \"target=_blank\"\n            !e.defaultPrevented && // onClick prevented default\n            !e.metaKey && // ignore clicks with modifier keys...\n            !e.altKey &&\n            !e.ctrlKey &&\n            !e.shiftKey\n          ) {\n            e.preventDefault()\n\n            let shouldReplace = replace\n            const isCurrent = encodeURI(prefixedTo) === _location.pathname\n\n            if (typeof replace !== `boolean` && isCurrent) {\n              shouldReplace = true\n            }\n            // Make sure the necessary scripts and data are\n            // loaded before continuing.\n            window.___navigate(prefixedTo, {\n              state,\n              replace: shouldReplace,\n            })\n          }\n\n          return true\n        }}\n        {...rest}\n      />\n    )\n  }\n}\n\nGatsbyLink.propTypes = {\n  ...NavLinkPropTypes,\n  onClick: PropTypes.func,\n  to: PropTypes.string.isRequired,\n  replace: PropTypes.bool,\n  state: PropTypes.object,\n}\n\nexport const Link = React.forwardRef((props, ref) => (\n  <GatsbyLinkLocationWrapper innerRef={ref} {...props} />\n))\n\nexport const navigate = (to, options) => {\n  window.___navigate(rewriteLinkPath(to, window.location.pathname), options)\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}