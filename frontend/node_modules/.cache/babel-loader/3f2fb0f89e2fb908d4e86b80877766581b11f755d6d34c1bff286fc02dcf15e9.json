{"ast":null,"code":"\"use client\";\n\nimport t, { useEffect as e } from \"react\";\nimport { Location as n, useLocation as r } from \"@gatsbyjs/reach-router\";\nfunction o() {\n  return o = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n    return t;\n  }, o.apply(this, arguments);\n}\nconst a = new Map(),\n  l = {\n    get: t => a.get(t) || [],\n    set(t, e) {\n      const n = a.get(t) || [];\n      n.push(e), a.set(t, n);\n    },\n    delete(t) {\n      a.delete(t);\n    }\n  },\n  s = \"undefined\" != typeof self && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function (t) {\n    const e = Date.now();\n    return setTimeout(function () {\n      t({\n        didTimeout: !1,\n        timeRemaining: function () {\n          return Math.max(0, 50 - (Date.now() - e));\n        }\n      });\n    }, 1);\n  };\nvar c;\n!function (t) {\n  t.postHydrate = \"post-hydrate\", t.idle = \"idle\", t.offMainThread = \"off-main-thread\";\n}(c || (c = {}));\nconst i = new Set([\"src\", \"strategy\", \"dangerouslySetInnerHTML\", \"children\", \"onLoad\", \"onError\"]),\n  u = new Set(),\n  d = new Map();\nfunction f(e) {\n  /*#__PURE__*/return t.createElement(n, null, () => /*#__PURE__*/t.createElement(p, e));\n}\nfunction p(n) {\n  const {\n      src: a,\n      strategy: i = c.postHydrate\n    } = n || {},\n    {\n      pathname: u\n    } = r();\n  if (e(() => {\n    let t;\n    switch (i) {\n      case c.postHydrate:\n        t = y(n);\n        break;\n      case c.idle:\n        s(() => {\n          t = y(n);\n        });\n        break;\n      case c.offMainThread:\n        {\n          const t = b(n);\n          l.set(u, t);\n        }\n    }\n    return () => {\n      const {\n        script: e,\n        loadCallback: n,\n        errorCallback: r\n      } = t || {};\n      n && (null == e || e.removeEventListener(\"load\", n)), r && (null == e || e.removeEventListener(\"error\", r)), null == e || e.remove();\n    };\n  }, []), i === c.offMainThread) {\n    const e = m(n),\n      r = b(n);\n    return \"undefined\" == typeof window && l.set(u, r), /*#__PURE__*/t.createElement(\"script\", e ? o({\n      type: \"text/partytown\",\n      \"data-strategy\": i,\n      crossOrigin: \"anonymous\"\n    }, r, {\n      dangerouslySetInnerHTML: {\n        __html: m(n)\n      }\n    }) : o({\n      type: \"text/partytown\",\n      src: h(a),\n      \"data-strategy\": i,\n      crossOrigin: \"anonymous\"\n    }, r));\n  }\n  return null;\n}\nfunction y(t) {\n  const {\n      id: e,\n      src: n,\n      strategy: r = c.postHydrate,\n      onLoad: a,\n      onError: l\n    } = t || {},\n    s = e || n,\n    i = [\"load\", \"error\"],\n    f = {\n      load: a,\n      error: l\n    };\n  if (s) {\n    for (const t of i) if (null != f && f[t]) {\n      var p;\n      const e = d.get(s) || {},\n        {\n          callbacks: n = []\n        } = (null == e ? void 0 : e[t]) || {};\n      var y, h;\n      n.push(null == f ? void 0 : f[t]), null != e && null != (p = e[t]) && p.event ? null == f || null == (y = f[t]) || y.call(f, null == e || null == (h = e[t]) ? void 0 : h.event) : d.set(s, o({}, e, {\n        [t]: {\n          callbacks: n\n        }\n      }));\n    }\n    if (u.has(s)) return null;\n  }\n  const v = m(t),\n    k = b(t),\n    w = document.createElement(\"script\");\n  e && (w.id = e), w.dataset.strategy = r;\n  for (const [t, e] of Object.entries(k)) w.setAttribute(t, e);\n  v && (w.textContent = v), n && (w.src = n);\n  const C = {};\n  if (s) {\n    for (const t of i) {\n      const e = e => g(e, s, t);\n      w.addEventListener(t, e), C[`${t}Callback`] = e;\n    }\n    u.add(s);\n  }\n  return document.body.appendChild(w), {\n    script: w,\n    loadCallback: C.loadCallback,\n    errorCallback: C.errorCallback\n  };\n}\nfunction m(t) {\n  const {\n      dangerouslySetInnerHTML: e,\n      children: n = \"\"\n    } = t || {},\n    {\n      __html: r = \"\"\n    } = e || {};\n  return r || n;\n}\nfunction b(t) {\n  const e = {};\n  for (const [n, r] of Object.entries(t)) i.has(n) || (e[n] = r);\n  return e;\n}\nfunction h(t) {\n  if (t) return `/__third-party-proxy?url=${encodeURIComponent(t)}`;\n}\nfunction g(t, e, n) {\n  const r = d.get(e) || {};\n  for (const e of (null == r || null == (o = r[n]) ? void 0 : o.callbacks) || []) {\n    var o;\n    e(t);\n  }\n  d.set(e, {\n    [n]: {\n      event: t\n    }\n  });\n}\nexport { f as Script, c as ScriptStrategy, l as collectedScriptsByPage, u as scriptCache, d as scriptCallbackCache };","map":{"version":3,"names":[],"sources":["/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-script/src/collected-scripts-by-page.tsx","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-script/src/request-idle-callback-shim.ts","/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby-script/src/gatsby-script.tsx"],"sourcesContent":["import { ScriptProps } from \"./gatsby-script\"\n\nconst _collectedScriptsByPage = new Map()\n\nexport const collectedScriptsByPage = {\n  get(pathname: string): Array<ScriptProps> {\n    return _collectedScriptsByPage.get(pathname) || []\n  },\n  set(pathname: string, collectedScript: ScriptProps): void {\n    const currentCollectedScripts = _collectedScriptsByPage.get(pathname) || []\n    currentCollectedScripts.push(collectedScript)\n    _collectedScriptsByPage.set(pathname, currentCollectedScripts)\n  },\n  delete(pathname: string): void {\n    _collectedScriptsByPage.delete(pathname)\n  },\n}\n","// https://developer.chrome.com/blog/using-requestidlecallback/#checking-for-requestidlecallback\n// https://github.com/vercel/next.js/blob/canary/packages/next/client/request-idle-callback.ts\n\nexport const requestIdleCallback =\n  (typeof self !== `undefined` &&\n    self.requestIdleCallback &&\n    self.requestIdleCallback.bind(window)) ||\n  function (cb: IdleRequestCallback): number {\n    const start = Date.now()\n    return setTimeout(function () {\n      cb({\n        didTimeout: false,\n        timeRemaining: function () {\n          return Math.max(0, 50 - (Date.now() - start))\n        },\n      })\n    }, 1) as unknown as number\n  }\n","import React, { useEffect } from \"react\"\nimport { collectedScriptsByPage } from \"./collected-scripts-by-page\"\nimport type { ReactElement, ScriptHTMLAttributes } from \"react\"\nimport { requestIdleCallback } from \"./request-idle-callback-shim\"\nimport { Location, useLocation } from \"@gatsbyjs/reach-router\"\n\nexport enum ScriptStrategy {\n  postHydrate = `post-hydrate`,\n  idle = `idle`,\n  offMainThread = `off-main-thread`,\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface ScriptProps\n  extends Omit<ScriptHTMLAttributes<HTMLScriptElement>, `onLoad` | `onError`> {\n  id?: string\n  strategy?: ScriptStrategy | `post-hydrate` | `idle` | `off-main-thread`\n  children?: string\n  onLoad?: (event: Event) => void\n  onError?: (event: ErrorEvent) => void\n  forward?: Array<string>\n}\n\nconst handledProps = new Set([\n  `src`,\n  `strategy`,\n  `dangerouslySetInnerHTML`,\n  `children`,\n  `onLoad`,\n  `onError`,\n])\n\n// Used for de-duplication\nexport const scriptCache: Set<string> = new Set()\nexport const scriptCallbackCache: Map<\n  string,\n  {\n    load?: {\n      callbacks?: Array<(event: Event) => void>\n      event?: Event | undefined\n    }\n    error?: {\n      callbacks?: Array<(event: ErrorEvent) => void>\n      event?: ErrorEvent | undefined\n    }\n  }\n> = new Map()\n\n// Same pattern is used in Gatsby Link\nfunction GatsbyScriptLocationWrapper(props: ScriptProps): JSX.Element {\n  return <Location>{(): JSX.Element => <GatsbyScript {...props} />}</Location>\n}\n\nfunction GatsbyScript(props: ScriptProps): ReactElement | null {\n  const { src, strategy = ScriptStrategy.postHydrate } = props || {}\n\n  const { pathname } = useLocation()\n\n  useEffect(() => {\n    let details: IInjectedScriptDetails | null\n\n    switch (strategy) {\n      case ScriptStrategy.postHydrate:\n        details = injectScript(props)\n        break\n      case ScriptStrategy.idle:\n        requestIdleCallback(() => {\n          details = injectScript(props)\n        })\n        break\n      case ScriptStrategy.offMainThread:\n        {\n          const attributes = resolveAttributes(props)\n          collectedScriptsByPage.set(pathname, attributes)\n        }\n        break\n    }\n\n    return (): void => {\n      const { script, loadCallback, errorCallback } = details || {}\n\n      if (loadCallback) {\n        script?.removeEventListener(`load`, loadCallback)\n      }\n\n      if (errorCallback) {\n        script?.removeEventListener(`error`, errorCallback)\n      }\n\n      script?.remove()\n    }\n  }, [])\n\n  if (strategy === ScriptStrategy.offMainThread) {\n    const inlineScript = resolveInlineScript(props)\n    const attributes = resolveAttributes(props)\n\n    if (typeof window === `undefined`) {\n      collectedScriptsByPage.set(pathname, attributes)\n    }\n\n    if (inlineScript) {\n      return (\n        <script\n          type=\"text/partytown\"\n          data-strategy={strategy}\n          crossOrigin=\"anonymous\"\n          {...attributes}\n          dangerouslySetInnerHTML={{ __html: resolveInlineScript(props) }}\n        />\n      )\n    }\n    return (\n      <script\n        type=\"text/partytown\"\n        src={proxyPartytownUrl(src)}\n        data-strategy={strategy}\n        crossOrigin=\"anonymous\"\n        {...attributes}\n      />\n    )\n  }\n\n  return null\n}\n\ninterface IInjectedScriptDetails {\n  script: HTMLScriptElement | null\n  loadCallback: (event: Event) => void\n  errorCallback: (event: ErrorEvent) => void\n}\n\nfunction injectScript(props: ScriptProps): IInjectedScriptDetails | null {\n  const {\n    id,\n    src,\n    strategy = ScriptStrategy.postHydrate,\n    onLoad,\n    onError,\n  } = props || {}\n\n  const scriptKey = id || src\n\n  const callbackNames = [`load`, `error`]\n\n  const currentCallbacks = {\n    load: onLoad,\n    error: onError,\n  }\n\n  if (scriptKey) {\n    /**\n     * If a duplicate script is already loaded/errored, we replay load/error callbacks with the original event.\n     * If it's not yet loaded/errored, keep track of callbacks so we can call load/error callbacks for each when the event occurs.\n     */\n    for (const name of callbackNames) {\n      if (currentCallbacks?.[name]) {\n        const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {}\n        const { callbacks = [] } = cachedCallbacks?.[name] || {}\n        callbacks.push(currentCallbacks?.[name])\n\n        if (cachedCallbacks?.[name]?.event) {\n          currentCallbacks?.[name]?.(cachedCallbacks?.[name]?.event)\n        } else {\n          scriptCallbackCache.set(scriptKey, {\n            ...cachedCallbacks,\n            [name]: {\n              callbacks,\n            },\n          })\n        }\n      }\n    }\n\n    // Avoid injecting duplicate scripts into the DOM\n    if (scriptCache.has(scriptKey)) {\n      return null\n    }\n  }\n\n  const inlineScript = resolveInlineScript(props)\n  const attributes = resolveAttributes(props)\n\n  const script = document.createElement(`script`)\n\n  if (id) {\n    script.id = id\n  }\n\n  script.dataset.strategy = strategy\n\n  for (const [key, value] of Object.entries(attributes)) {\n    script.setAttribute(key, value)\n  }\n\n  if (inlineScript) {\n    script.textContent = inlineScript\n  }\n\n  if (src) {\n    script.src = src\n  }\n\n  const wrappedCallbacks: Record<string, (event: Event | ErrorEvent) => void> =\n    {}\n\n  if (scriptKey) {\n    // Add listeners on injected scripts so events are cached for use in de-duplicated script callbacks\n    for (const name of callbackNames) {\n      const wrappedEventCallback = (event: Event | ErrorEvent): void =>\n        onEventCallback(event, scriptKey, name)\n      script.addEventListener(name, wrappedEventCallback)\n      wrappedCallbacks[`${name}Callback`] = wrappedEventCallback\n    }\n\n    scriptCache.add(scriptKey)\n  }\n\n  document.body.appendChild(script)\n\n  return {\n    script,\n    loadCallback: wrappedCallbacks.loadCallback,\n    errorCallback: wrappedCallbacks.errorCallback,\n  }\n}\n\nfunction resolveInlineScript(props: ScriptProps): string {\n  const { dangerouslySetInnerHTML, children = `` } = props || {}\n  const { __html: dangerousHTML = `` } = dangerouslySetInnerHTML || {}\n  return (dangerousHTML as string) || children\n}\n\nfunction resolveAttributes(props: ScriptProps): Record<string, string> {\n  const attributes: Record<string, string> = {}\n\n  for (const [key, value] of Object.entries(props)) {\n    if (handledProps.has(key)) {\n      continue\n    }\n    attributes[key] = value\n  }\n\n  return attributes\n}\n\nfunction proxyPartytownUrl(url: string | undefined): string | undefined {\n  if (!url) {\n    return undefined\n  }\n  return `/__third-party-proxy?url=${encodeURIComponent(url)}`\n}\n\nfunction onEventCallback(\n  event: Event | ErrorEvent,\n  scriptKey: string,\n  eventName: string\n): void {\n  const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {}\n\n  for (const callback of cachedCallbacks?.[eventName]?.callbacks || []) {\n    callback(event)\n  }\n\n  scriptCallbackCache.set(scriptKey, { [eventName]: { event } })\n}\n\nexport { GatsbyScriptLocationWrapper as Script }\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}