{"ast":null,"code":"import { createFromReadableStream } from \"react-server-dom-webpack\";\nimport prefetchHelper from \"./prefetch\";\nimport emitter from \"./emitter\";\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\";\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`\n};\nconst preferDefault = m => m && m.default || m;\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s;\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s;\n  return s;\n};\nconst createPageDataUrl = rawPath => {\n  const [path, maybeSearch] = rawPath.split(`?`);\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path);\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json${maybeSearch ? `?${maybeSearch}` : ``}`;\n};\n\n/**\n * Utility to check the path that goes into doFetch for e.g. potential malicious intentions.\n * It checks for \"//\" because with this you could do a fetch request to a different domain.\n */\nconst shouldAbortFetch = rawPath => rawPath.startsWith(`//`);\nfunction doFetch(url, method = `GET`) {\n  return new Promise(resolve => {\n    const req = new XMLHttpRequest();\n    req.open(method, url, true);\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req);\n      }\n    };\n    req.send(null);\n  });\n}\nconst doesConnectionSupportPrefetch = () => {\n  if (`connection` in navigator && typeof navigator.connection !== `undefined`) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false;\n    }\n    if (navigator.connection.saveData) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Regex that matches common search crawlers\nconst BOT_REGEX = /bot|crawler|spider|crawling/i;\nconst toPageResources = (pageData, component = null, head) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n    staticQueryHashes: pageData.staticQueryHashes,\n    getServerDataError: pageData.getServerDataError,\n    slicesMap: pageData.slicesMap ?? {}\n  };\n  return {\n    component,\n    head,\n    json: pageData.result,\n    page\n  };\n};\nfunction waitForResponse(response) {\n  return new Promise(resolve => {\n    try {\n      const result = response.readRoot();\n      resolve(result);\n    } catch (err) {\n      if (Object.hasOwnProperty.call(err, `_response`) && Object.hasOwnProperty.call(err, `_status`)) {\n        setTimeout(() => {\n          waitForResponse(response).then(resolve);\n        }, 200);\n      } else {\n        throw err;\n      }\n    }\n  });\n}\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //     staticQueryHashes\n    //   },\n    //   staticQueryResults\n    // }\n    this.pageDb = new Map();\n    this.inFlightDb = new Map();\n    this.staticQueryDb = {};\n    this.pageDataDb = new Map();\n    this.partialHydrationDb = new Map();\n    this.slicesDataDb = new Map();\n    this.sliceInflightDb = new Map();\n    this.slicesDb = new Map();\n    this.isPrefetchQueueRunning = false;\n    this.prefetchQueued = [];\n    this.prefetchTriggered = new Set();\n    this.prefetchCompleted = new Set();\n    this.loadComponent = loadComponent;\n    setMatchPaths(matchPaths);\n  }\n  inFlightNetworkRequests = new Map();\n  memoizedGet(url) {\n    let inFlightPromise = this.inFlightNetworkRequests.get(url);\n    if (!inFlightPromise) {\n      inFlightPromise = doFetch(url, `GET`);\n      this.inFlightNetworkRequests.set(url, inFlightPromise);\n    }\n\n    // Prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n    return inFlightPromise.then(response => {\n      this.inFlightNetworkRequests.delete(url);\n      return response;\n    }).catch(err => {\n      this.inFlightNetworkRequests.delete(url);\n      throw err;\n    });\n  }\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner;\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a);\n  }\n  fetchPageDataJson(loadObj) {\n    const {\n      pagePath,\n      retries = 0\n    } = loadObj;\n    const url = createPageDataUrl(pagePath);\n    return this.memoizedGet(url).then(req => {\n      const {\n        status,\n        responseText\n      } = req;\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText);\n          if (jsonPayload.path === undefined) {\n            throw new Error(`not a valid pageData response`);\n          }\n          const maybeSearch = pagePath.split(`?`)[1];\n          if (maybeSearch && !jsonPayload.path.includes(maybeSearch)) {\n            jsonPayload.path += `?${maybeSearch}`;\n          }\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: jsonPayload\n          });\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404/500 page and it doesn't exist, we're done\n        if (pagePath === `/404.html` || pagePath === `/500.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error\n          });\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPageDataJson(Object.assign(loadObj, {\n          pagePath: `/404.html`,\n          notFound: true\n        }));\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return this.fetchPageDataJson(Object.assign(loadObj, {\n          pagePath: `/500.html`,\n          internalServerError: true\n        }));\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPageDataJson(Object.assign(loadObj, {\n          retries: retries + 1\n        }));\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error\n      });\n    });\n  }\n  fetchPartialHydrationJson(loadObj) {\n    const {\n      pagePath,\n      retries = 0\n    } = loadObj;\n    const url = createPageDataUrl(pagePath).replace(`.json`, `-rsc.json`);\n    return this.memoizedGet(url).then(req => {\n      const {\n        status,\n        responseText\n      } = req;\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: responseText\n          });\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404/500 page and it doesn't exist, we're done\n        if (pagePath === `/404.html` || pagePath === `/500.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error\n          });\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPartialHydrationJson(Object.assign(loadObj, {\n          pagePath: `/404.html`,\n          notFound: true\n        }));\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return this.fetchPartialHydrationJson(Object.assign(loadObj, {\n          pagePath: `/500.html`,\n          internalServerError: true\n        }));\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPartialHydrationJson(Object.assign(loadObj, {\n          retries: retries + 1\n        }));\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error\n      });\n    });\n  }\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath);\n    if (this.pageDataDb.has(pagePath)) {\n      const pageData = this.pageDataDb.get(pagePath);\n      if (process.env.BUILD_STAGE !== `develop` || !pageData.stale) {\n        return Promise.resolve(pageData);\n      }\n    }\n    return this.fetchPageDataJson({\n      pagePath\n    }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData);\n      return pageData;\n    });\n  }\n  loadPartialHydrationJson(rawPath) {\n    const pagePath = findPath(rawPath);\n    if (this.partialHydrationDb.has(pagePath)) {\n      const pageData = this.partialHydrationDb.get(pagePath);\n      if (process.env.BUILD_STAGE !== `develop` || !pageData.stale) {\n        return Promise.resolve(pageData);\n      }\n    }\n    return this.fetchPartialHydrationJson({\n      pagePath\n    }).then(pageData => {\n      this.partialHydrationDb.set(pagePath, pageData);\n      return pageData;\n    });\n  }\n  loadSliceDataJson(sliceName) {\n    if (this.slicesDataDb.has(sliceName)) {\n      const jsonPayload = this.slicesDataDb.get(sliceName);\n      return Promise.resolve({\n        sliceName,\n        jsonPayload\n      });\n    }\n    const url = `${__PATH_PREFIX__}/slice-data/${sliceName}.json`;\n    return doFetch(url, `GET`).then(res => {\n      const jsonPayload = JSON.parse(res.responseText);\n      this.slicesDataDb.set(sliceName, jsonPayload);\n      return {\n        sliceName,\n        jsonPayload\n      };\n    });\n  }\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath);\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath);\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath);\n      if (process.env.BUILD_STAGE !== `develop` || !page.payload.stale) {\n        if (page.error) {\n          return Promise.resolve({\n            error: page.error,\n            status: page.status\n          });\n        }\n        return Promise.resolve(page.payload);\n      }\n    }\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath);\n    }\n    const loadDataPromises = [this.loadAppData(), this.loadPageDataJson(pagePath)];\n    if (global.hasPartialHydration) {\n      loadDataPromises.push(this.loadPartialHydrationJson(pagePath));\n    }\n    const inFlightPromise = Promise.all(loadDataPromises).then(allData => {\n      const [appDataResponse, pageDataResponse, rscDataResponse] = allData;\n      if (pageDataResponse.status === PageResourceStatus.Error || rscDataResponse?.status === PageResourceStatus.Error) {\n        return {\n          status: PageResourceStatus.Error\n        };\n      }\n      let pageData = pageDataResponse.payload;\n      const {\n        componentChunkName,\n        staticQueryHashes: pageStaticQueryHashes = [],\n        slicesMap = {}\n      } = pageData;\n      const finalResult = {};\n      const dedupedSliceNames = Array.from(new Set(Object.values(slicesMap)));\n      const loadSlice = slice => {\n        if (this.slicesDb.has(slice.name)) {\n          return this.slicesDb.get(slice.name);\n        } else if (this.sliceInflightDb.has(slice.name)) {\n          return this.sliceInflightDb.get(slice.name);\n        }\n        const inFlight = this.loadComponent(slice.componentChunkName).then(component => {\n          return {\n            component: preferDefault(component),\n            sliceContext: slice.result.sliceContext,\n            data: slice.result.data\n          };\n        });\n        this.sliceInflightDb.set(slice.name, inFlight);\n        inFlight.then(results => {\n          this.slicesDb.set(slice.name, results);\n          this.sliceInflightDb.delete(slice.name);\n        });\n        return inFlight;\n      };\n      return Promise.all(dedupedSliceNames.map(sliceName => this.loadSliceDataJson(sliceName))).then(slicesData => {\n        const slices = [];\n        const dedupedStaticQueryHashes = [...pageStaticQueryHashes];\n        for (const {\n          jsonPayload,\n          sliceName\n        } of Object.values(slicesData)) {\n          slices.push({\n            name: sliceName,\n            ...jsonPayload\n          });\n          for (const staticQueryHash of jsonPayload.staticQueryHashes) {\n            if (!dedupedStaticQueryHashes.includes(staticQueryHash)) {\n              dedupedStaticQueryHashes.push(staticQueryHash);\n            }\n          }\n        }\n        const loadChunkPromises = [Promise.all(slices.map(loadSlice)), this.loadComponent(componentChunkName, `head`)];\n        if (!global.hasPartialHydration) {\n          loadChunkPromises.push(this.loadComponent(componentChunkName));\n        }\n\n        // In develop we have separate chunks for template and Head components\n        // to enable HMR (fast refresh requires single exports).\n        // In production we have shared chunk with both exports. Double loadComponent here\n        // will be deduped by webpack runtime resulting in single request and single module\n        // being loaded for both `component` and `head`.\n        // get list of components to get\n        const componentChunkPromises = Promise.all(loadChunkPromises).then(components => {\n          const [sliceComponents, headComponent, pageComponent] = components;\n          finalResult.createdAt = new Date();\n          for (const sliceComponent of sliceComponents) {\n            if (!sliceComponent || sliceComponent instanceof Error) {\n              finalResult.status = PageResourceStatus.Error;\n              finalResult.error = sliceComponent;\n            }\n          }\n          if (!global.hasPartialHydration && (!pageComponent || pageComponent instanceof Error)) {\n            finalResult.status = PageResourceStatus.Error;\n            finalResult.error = pageComponent;\n          }\n          let pageResources;\n          if (finalResult.status !== PageResourceStatus.Error) {\n            finalResult.status = PageResourceStatus.Success;\n            if (pageDataResponse.notFound === true || rscDataResponse?.notFound === true) {\n              finalResult.notFound = true;\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: appDataResponse ? appDataResponse.webpackCompilationHash : ``\n            });\n            if (typeof rscDataResponse?.payload === `string`) {\n              pageResources = toPageResources(pageData, null, headComponent);\n              pageResources.partialHydration = rscDataResponse.payload;\n              const readableStream = new ReadableStream({\n                start(controller) {\n                  const te = new TextEncoder();\n                  controller.enqueue(te.encode(rscDataResponse.payload));\n                },\n                pull(controller) {\n                  // close on next read when queue is empty\n                  controller.close();\n                },\n                cancel() {}\n              });\n              return waitForResponse(createFromReadableStream(readableStream)).then(result => {\n                pageResources.partialHydration = result;\n                return pageResources;\n              });\n            } else {\n              pageResources = toPageResources(pageData, pageComponent, headComponent);\n            }\n          }\n\n          // undefined if final result is an error\n          return pageResources;\n        });\n\n        // get list of static queries to get\n        const staticQueryBatchPromise = Promise.all(dedupedStaticQueryHashes.map(staticQueryHash => {\n          // Check for cache in case this static query result has already been loaded\n          if (this.staticQueryDb[staticQueryHash]) {\n            const jsonPayload = this.staticQueryDb[staticQueryHash];\n            return {\n              staticQueryHash,\n              jsonPayload\n            };\n          }\n          return this.memoizedGet(`${__PATH_PREFIX__}/page-data/sq/d/${staticQueryHash}.json`).then(req => {\n            const jsonPayload = JSON.parse(req.responseText);\n            return {\n              staticQueryHash,\n              jsonPayload\n            };\n          }).catch(() => {\n            throw new Error(`We couldn't load \"${__PATH_PREFIX__}/page-data/sq/d/${staticQueryHash}.json\"`);\n          });\n        })).then(staticQueryResults => {\n          const staticQueryResultsMap = {};\n          staticQueryResults.forEach(({\n            staticQueryHash,\n            jsonPayload\n          }) => {\n            staticQueryResultsMap[staticQueryHash] = jsonPayload;\n            this.staticQueryDb[staticQueryHash] = jsonPayload;\n          });\n          return staticQueryResultsMap;\n        });\n        return Promise.all([componentChunkPromises, staticQueryBatchPromise]).then(([pageResources, staticQueryResults]) => {\n          let payload;\n          if (pageResources) {\n            payload = {\n              ...pageResources,\n              staticQueryResults\n            };\n            finalResult.payload = payload;\n            emitter.emit(`onPostLoadPageResources`, {\n              page: payload,\n              pageResources: payload\n            });\n          }\n          this.pageDb.set(pagePath, finalResult);\n          if (finalResult.error) {\n            return {\n              error: finalResult.error,\n              status: finalResult.status\n            };\n          }\n          return payload;\n        })\n        // when static-query fail to load we throw a better error\n        .catch(err => {\n          return {\n            error: err,\n            status: PageResourceStatus.Error\n          };\n        });\n      });\n    });\n    inFlightPromise.then(() => {\n      this.inFlightDb.delete(pagePath);\n    }).catch(error => {\n      this.inFlightDb.delete(pagePath);\n      throw error;\n    });\n    this.inFlightDb.set(pagePath, inFlightPromise);\n    return inFlightPromise;\n  }\n\n  // returns undefined if the page does not exists in cache\n  loadPageSync(rawPath, options = {}) {\n    const pagePath = findPath(rawPath);\n    if (this.pageDb.has(pagePath)) {\n      const pageData = this.pageDb.get(pagePath);\n      if (pageData.payload) {\n        return pageData.payload;\n      }\n      if (options?.withErrorDetails) {\n        return {\n          error: pageData.error,\n          status: pageData.status\n        };\n      }\n    }\n    return undefined;\n  }\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false;\n    }\n\n    // Don't prefetch if this is a crawler bot\n    if (navigator.userAgent && BOT_REGEX.test(navigator.userAgent)) {\n      return false;\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false;\n    }\n    return true;\n  }\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return {\n        then: resolve => resolve(false),\n        abort: () => {}\n      };\n    }\n    if (this.prefetchTriggered.has(pagePath)) {\n      return {\n        then: resolve => resolve(true),\n        abort: () => {}\n      };\n    }\n    const defer = {\n      resolve: null,\n      reject: null,\n      promise: null\n    };\n    defer.promise = new Promise((resolve, reject) => {\n      defer.resolve = resolve;\n      defer.reject = reject;\n    });\n    this.prefetchQueued.push([pagePath, defer]);\n    const abortC = new AbortController();\n    abortC.signal.addEventListener(`abort`, () => {\n      const index = this.prefetchQueued.findIndex(([p]) => p === pagePath);\n      // remove from the queue\n      if (index !== -1) {\n        this.prefetchQueued.splice(index, 1);\n      }\n    });\n    if (!this.isPrefetchQueueRunning) {\n      this.isPrefetchQueueRunning = true;\n      setTimeout(() => {\n        this._processNextPrefetchBatch();\n      }, 3000);\n    }\n    return {\n      then: (resolve, reject) => defer.promise.then(resolve, reject),\n      abort: abortC.abort.bind(abortC)\n    };\n  }\n  _processNextPrefetchBatch() {\n    const idleCallback = window.requestIdleCallback || (cb => setTimeout(cb, 0));\n    idleCallback(() => {\n      const toPrefetch = this.prefetchQueued.splice(0, 4);\n      const prefetches = Promise.all(toPrefetch.map(([pagePath, dPromise]) => {\n        // Tell plugins with custom prefetching logic that they should start\n        // prefetching this path.\n        if (!this.prefetchTriggered.has(pagePath)) {\n          this.apiRunner(`onPrefetchPathname`, {\n            pathname: pagePath\n          });\n          this.prefetchTriggered.add(pagePath);\n        }\n\n        // If a plugin has disabled core prefetching, stop now.\n        if (this.prefetchDisabled) {\n          return dPromise.resolve(false);\n        }\n        return this.doPrefetch(findPath(pagePath)).then(() => {\n          if (!this.prefetchCompleted.has(pagePath)) {\n            this.apiRunner(`onPostPrefetchPathname`, {\n              pathname: pagePath\n            });\n            this.prefetchCompleted.add(pagePath);\n          }\n          dPromise.resolve(true);\n        });\n      }));\n      if (this.prefetchQueued.length) {\n        prefetches.then(() => {\n          setTimeout(() => {\n            this._processNextPrefetchBatch();\n          }, 3000);\n        });\n      } else {\n        this.isPrefetchQueueRunning = false;\n      }\n    });\n  }\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath);\n    if (global.hasPartialHydration) {\n      return Promise.all([prefetchHelper(pageDataUrl, {\n        crossOrigin: `anonymous`,\n        as: `fetch`\n      }).then(() =>\n      // This was just prefetched, so will return a response from\n      // the cache instead of making another request to the server\n      this.loadPageDataJson(pagePath)), prefetchHelper(pageDataUrl.replace(`.json`, `-rsc.json`), {\n        crossOrigin: `anonymous`,\n        as: `fetch`\n      }).then(() =>\n      // This was just prefetched, so will return a response from\n      // the cache instead of making another request to the server\n      this.loadPartialHydrationJson(pagePath))]);\n    } else {\n      return prefetchHelper(pageDataUrl, {\n        crossOrigin: `anonymous`,\n        as: `fetch`\n      }).then(() =>\n      // This was just prefetched, so will return a response from\n      // the cache instead of making another request to the server\n      this.loadPageDataJson(pagePath));\n    }\n  }\n  hovering(rawPath) {\n    this.loadPage(rawPath);\n  }\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath);\n    const page = this.pageDataDb.get(pagePath);\n    if (page) {\n      const pageResources = toPageResources(page.payload);\n      return [...createComponentUrls(pageResources.page.componentChunkName), createPageDataUrl(pagePath)];\n    } else {\n      return null;\n    }\n  }\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath);\n    const page = this.pageDb.get(pagePath);\n    return !page || page.notFound;\n  }\n  loadAppData(retries = 0) {\n    return this.memoizedGet(`${__PATH_PREFIX__}/page-data/app-data.json`).then(req => {\n      const {\n        status,\n        responseText\n      } = req;\n      let appData;\n      if (status !== 200 && retries < 3) {\n        // Retry 3 times incase of non-200 responses\n        return this.loadAppData(retries + 1);\n      }\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText);\n          if (jsonPayload.webpackCompilationHash === undefined) {\n            throw new Error(`not a valid app-data response`);\n          }\n          appData = jsonPayload;\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n      return appData;\n    });\n  }\n}\nconst createComponentUrls = componentChunkName => (window.___chunkMapping[componentChunkName] || []).map(chunk => __PATH_PREFIX__ + chunk);\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths, pageData) {\n    const loadComponent = (chunkName, exportType = `components`) => {\n      if (!global.hasPartialHydration) {\n        exportType = `components`;\n      }\n      if (!asyncRequires[exportType][chunkName]) {\n        throw new Error(`We couldn't find the correct component chunk with the name \"${chunkName}\"`);\n      }\n      return asyncRequires[exportType][chunkName]()\n      // loader will handle the case when component is error\n      .catch(err => err);\n    };\n    super(loadComponent, matchPaths);\n    if (pageData) {\n      this.pageDataDb.set(findPath(pageData.path), {\n        pagePath: pageData.path,\n        payload: pageData,\n        status: `success`\n      });\n    }\n  }\n  doPrefetch(pagePath) {\n    return super.doPrefetch(pagePath).then(result => {\n      if (result.status !== PageResourceStatus.Success) {\n        return Promise.resolve();\n      }\n      const pageData = result.payload;\n      const chunkName = pageData.componentChunkName;\n      const componentUrls = createComponentUrls(chunkName);\n      return Promise.all(componentUrls.map(prefetchHelper)).then(() => pageData);\n    });\n  }\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        if (shouldAbortFetch(rawPath)) {\n          return data;\n        }\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error\n            };\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data;\n        });\n      }\n      return data;\n    });\n  }\n  loadPartialHydrationJson(rawPath) {\n    return super.loadPartialHydrationJson(rawPath).then(data => {\n      if (data.notFound) {\n        if (shouldAbortFetch(rawPath)) {\n          return data;\n        }\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error\n            };\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data;\n        });\n      }\n      return data;\n    });\n  }\n}\nlet instance;\nexport const setLoader = _loader => {\n  instance = _loader;\n};\nexport const publicLoader = {\n  enqueue: rawPath => instance.prefetch(rawPath),\n  // Real methods\n  getResourceURLsForPathname: rawPath => instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  // TODO add deprecation to v4 so people use withErrorDetails and then we can remove in v5 and change default behaviour\n  loadPageSync: (rawPath, options = {}) => instance.loadPageSync(rawPath, options),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData()\n};\nexport default publicLoader;\nexport function getStaticQueryResults() {\n  if (instance) {\n    return instance.staticQueryDb;\n  } else {\n    return {};\n  }\n}\nexport function getSliceResults() {\n  if (instance) {\n    return instance.slicesDb;\n  } else {\n    return {};\n  }\n}","map":{"version":3,"names":["createFromReadableStream","prefetchHelper","emitter","setMatchPaths","findPath","findMatchPath","PageResourceStatus","Error","Success","preferDefault","m","default","stripSurroundingSlashes","s","slice","endsWith","createPageDataUrl","rawPath","path","maybeSearch","split","fixedPath","__PATH_PREFIX__","shouldAbortFetch","startsWith","doFetch","url","method","Promise","resolve","req","XMLHttpRequest","open","onreadystatechange","readyState","send","doesConnectionSupportPrefetch","navigator","connection","effectiveType","includes","saveData","BOT_REGEX","toPageResources","pageData","component","head","page","componentChunkName","webpackCompilationHash","matchPath","staticQueryHashes","getServerDataError","slicesMap","json","result","waitForResponse","response","readRoot","err","Object","hasOwnProperty","call","setTimeout","then","BaseLoader","constructor","loadComponent","matchPaths","pageDb","Map","inFlightDb","staticQueryDb","pageDataDb","partialHydrationDb","slicesDataDb","sliceInflightDb","slicesDb","isPrefetchQueueRunning","prefetchQueued","prefetchTriggered","Set","prefetchCompleted","inFlightNetworkRequests","memoizedGet","inFlightPromise","get","set","delete","catch","setApiRunner","apiRunner","prefetchDisabled","some","a","fetchPageDataJson","loadObj","pagePath","retries","status","responseText","jsonPayload","JSON","parse","undefined","assign","payload","notFound","internalServerError","fetchPartialHydrationJson","replace","loadPageDataJson","has","process","env","BUILD_STAGE","stale","loadPartialHydrationJson","loadSliceDataJson","sliceName","res","loadPage","error","loadDataPromises","loadAppData","global","hasPartialHydration","push","all","allData","appDataResponse","pageDataResponse","rscDataResponse","pageStaticQueryHashes","finalResult","dedupedSliceNames","Array","from","values","loadSlice","name","inFlight","sliceContext","data","results","map","slicesData","slices","dedupedStaticQueryHashes","staticQueryHash","loadChunkPromises","componentChunkPromises","components","sliceComponents","headComponent","pageComponent","createdAt","Date","sliceComponent","pageResources","partialHydration","readableStream","ReadableStream","start","controller","te","TextEncoder","enqueue","encode","pull","close","cancel","staticQueryBatchPromise","staticQueryResults","staticQueryResultsMap","forEach","emit","loadPageSync","options","withErrorDetails","shouldPrefetch","userAgent","test","prefetch","abort","defer","reject","promise","abortC","AbortController","signal","addEventListener","index","findIndex","p","splice","_processNextPrefetchBatch","bind","idleCallback","window","requestIdleCallback","cb","toPrefetch","prefetches","dPromise","pathname","add","doPrefetch","length","pageDataUrl","crossOrigin","as","hovering","getResourceURLsForPathname","createComponentUrls","isPageNotFound","appData","___chunkMapping","chunk","ProdLoader","asyncRequires","chunkName","exportType","componentUrls","instance","setLoader","_loader","publicLoader","getStaticQueryResults","getSliceResults"],"sources":["/home/rhydham/Documents/Tetime/frontend/node_modules/gatsby/cache-dir/loader.js"],"sourcesContent":["import { createFromReadableStream } from \"react-server-dom-webpack\"\nimport prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`,\n}\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = rawPath => {\n  const [path, maybeSearch] = rawPath.split(`?`)\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json${\n    maybeSearch ? `?${maybeSearch}` : ``\n  }`\n}\n\n/**\n * Utility to check the path that goes into doFetch for e.g. potential malicious intentions.\n * It checks for \"//\" because with this you could do a fetch request to a different domain.\n */\nconst shouldAbortFetch = rawPath => rawPath.startsWith(`//`)\n\nfunction doFetch(url, method = `GET`) {\n  return new Promise(resolve => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\n// Regex that matches common search crawlers\nconst BOT_REGEX = /bot|crawler|spider|crawling/i\n\nconst toPageResources = (pageData, component = null, head) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n    staticQueryHashes: pageData.staticQueryHashes,\n    getServerDataError: pageData.getServerDataError,\n    slicesMap: pageData.slicesMap ?? {},\n  }\n\n  return {\n    component,\n    head,\n    json: pageData.result,\n    page,\n  }\n}\n\nfunction waitForResponse(response) {\n  return new Promise(resolve => {\n    try {\n      const result = response.readRoot()\n      resolve(result)\n    } catch (err) {\n      if (\n        Object.hasOwnProperty.call(err, `_response`) &&\n        Object.hasOwnProperty.call(err, `_status`)\n      ) {\n        setTimeout(() => {\n          waitForResponse(response).then(resolve)\n        }, 200)\n      } else {\n        throw err\n      }\n    }\n  })\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //     staticQueryHashes\n    //   },\n    //   staticQueryResults\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.staticQueryDb = {}\n    this.pageDataDb = new Map()\n    this.partialHydrationDb = new Map()\n    this.slicesDataDb = new Map()\n    this.sliceInflightDb = new Map()\n    this.slicesDb = new Map()\n    this.isPrefetchQueueRunning = false\n    this.prefetchQueued = []\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  inFlightNetworkRequests = new Map()\n\n  memoizedGet(url) {\n    let inFlightPromise = this.inFlightNetworkRequests.get(url)\n\n    if (!inFlightPromise) {\n      inFlightPromise = doFetch(url, `GET`)\n      this.inFlightNetworkRequests.set(url, inFlightPromise)\n    }\n\n    // Prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n    return inFlightPromise\n      .then(response => {\n        this.inFlightNetworkRequests.delete(url)\n        return response\n      })\n      .catch(err => {\n        this.inFlightNetworkRequests.delete(url)\n        throw err\n      })\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  fetchPageDataJson(loadObj) {\n    const { pagePath, retries = 0 } = loadObj\n    const url = createPageDataUrl(pagePath)\n    return this.memoizedGet(url).then(req => {\n      const { status, responseText } = req\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.path === undefined) {\n            throw new Error(`not a valid pageData response`)\n          }\n\n          const maybeSearch = pagePath.split(`?`)[1]\n          if (maybeSearch && !jsonPayload.path.includes(maybeSearch)) {\n            jsonPayload.path += `?${maybeSearch}`\n          }\n\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: jsonPayload,\n          })\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404/500 page and it doesn't exist, we're done\n        if (pagePath === `/404.html` || pagePath === `/500.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error,\n          })\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n        )\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, {\n            pagePath: `/500.html`,\n            internalServerError: true,\n          })\n        )\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { retries: retries + 1 })\n        )\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    })\n  }\n\n  fetchPartialHydrationJson(loadObj) {\n    const { pagePath, retries = 0 } = loadObj\n    const url = createPageDataUrl(pagePath).replace(`.json`, `-rsc.json`)\n    return this.memoizedGet(url).then(req => {\n      const { status, responseText } = req\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: responseText,\n          })\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404/500 page and it doesn't exist, we're done\n        if (pagePath === `/404.html` || pagePath === `/500.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error,\n          })\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPartialHydrationJson(\n          Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n        )\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return this.fetchPartialHydrationJson(\n          Object.assign(loadObj, {\n            pagePath: `/500.html`,\n            internalServerError: true,\n          })\n        )\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPartialHydrationJson(\n          Object.assign(loadObj, { retries: retries + 1 })\n        )\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      const pageData = this.pageDataDb.get(pagePath)\n      if (process.env.BUILD_STAGE !== `develop` || !pageData.stale) {\n        return Promise.resolve(pageData)\n      }\n    }\n\n    return this.fetchPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  loadPartialHydrationJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.partialHydrationDb.has(pagePath)) {\n      const pageData = this.partialHydrationDb.get(pagePath)\n      if (process.env.BUILD_STAGE !== `develop` || !pageData.stale) {\n        return Promise.resolve(pageData)\n      }\n    }\n\n    return this.fetchPartialHydrationJson({ pagePath }).then(pageData => {\n      this.partialHydrationDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  loadSliceDataJson(sliceName) {\n    if (this.slicesDataDb.has(sliceName)) {\n      const jsonPayload = this.slicesDataDb.get(sliceName)\n      return Promise.resolve({ sliceName, jsonPayload })\n    }\n\n    const url = `${__PATH_PREFIX__}/slice-data/${sliceName}.json`\n    return doFetch(url, `GET`).then(res => {\n      const jsonPayload = JSON.parse(res.responseText)\n\n      this.slicesDataDb.set(sliceName, jsonPayload)\n      return { sliceName, jsonPayload }\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      if (process.env.BUILD_STAGE !== `develop` || !page.payload.stale) {\n        if (page.error) {\n          return Promise.resolve({\n            error: page.error,\n            status: page.status,\n          })\n        }\n\n        return Promise.resolve(page.payload)\n      }\n    }\n\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const loadDataPromises = [\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ]\n\n    if (global.hasPartialHydration) {\n      loadDataPromises.push(this.loadPartialHydrationJson(pagePath))\n    }\n\n    const inFlightPromise = Promise.all(loadDataPromises).then(allData => {\n      const [appDataResponse, pageDataResponse, rscDataResponse] = allData\n\n      if (\n        pageDataResponse.status === PageResourceStatus.Error ||\n        rscDataResponse?.status === PageResourceStatus.Error\n      ) {\n        return {\n          status: PageResourceStatus.Error,\n        }\n      }\n\n      let pageData = pageDataResponse.payload\n\n      const {\n        componentChunkName,\n        staticQueryHashes: pageStaticQueryHashes = [],\n        slicesMap = {},\n      } = pageData\n\n      const finalResult = {}\n\n      const dedupedSliceNames = Array.from(new Set(Object.values(slicesMap)))\n\n      const loadSlice = slice => {\n        if (this.slicesDb.has(slice.name)) {\n          return this.slicesDb.get(slice.name)\n        } else if (this.sliceInflightDb.has(slice.name)) {\n          return this.sliceInflightDb.get(slice.name)\n        }\n\n        const inFlight = this.loadComponent(slice.componentChunkName).then(\n          component => {\n            return {\n              component: preferDefault(component),\n              sliceContext: slice.result.sliceContext,\n              data: slice.result.data,\n            }\n          }\n        )\n\n        this.sliceInflightDb.set(slice.name, inFlight)\n        inFlight.then(results => {\n          this.slicesDb.set(slice.name, results)\n          this.sliceInflightDb.delete(slice.name)\n        })\n\n        return inFlight\n      }\n\n      return Promise.all(\n        dedupedSliceNames.map(sliceName => this.loadSliceDataJson(sliceName))\n      ).then(slicesData => {\n        const slices = []\n        const dedupedStaticQueryHashes = [...pageStaticQueryHashes]\n\n        for (const { jsonPayload, sliceName } of Object.values(slicesData)) {\n          slices.push({ name: sliceName, ...jsonPayload })\n          for (const staticQueryHash of jsonPayload.staticQueryHashes) {\n            if (!dedupedStaticQueryHashes.includes(staticQueryHash)) {\n              dedupedStaticQueryHashes.push(staticQueryHash)\n            }\n          }\n        }\n\n        const loadChunkPromises = [\n          Promise.all(slices.map(loadSlice)),\n          this.loadComponent(componentChunkName, `head`),\n        ]\n\n        if (!global.hasPartialHydration) {\n          loadChunkPromises.push(this.loadComponent(componentChunkName))\n        }\n\n        // In develop we have separate chunks for template and Head components\n        // to enable HMR (fast refresh requires single exports).\n        // In production we have shared chunk with both exports. Double loadComponent here\n        // will be deduped by webpack runtime resulting in single request and single module\n        // being loaded for both `component` and `head`.\n        // get list of components to get\n        const componentChunkPromises = Promise.all(loadChunkPromises).then(\n          components => {\n            const [sliceComponents, headComponent, pageComponent] = components\n\n            finalResult.createdAt = new Date()\n\n            for (const sliceComponent of sliceComponents) {\n              if (!sliceComponent || sliceComponent instanceof Error) {\n                finalResult.status = PageResourceStatus.Error\n                finalResult.error = sliceComponent\n              }\n            }\n\n            if (\n              !global.hasPartialHydration &&\n              (!pageComponent || pageComponent instanceof Error)\n            ) {\n              finalResult.status = PageResourceStatus.Error\n              finalResult.error = pageComponent\n            }\n\n            let pageResources\n\n            if (finalResult.status !== PageResourceStatus.Error) {\n              finalResult.status = PageResourceStatus.Success\n              if (\n                pageDataResponse.notFound === true ||\n                rscDataResponse?.notFound === true\n              ) {\n                finalResult.notFound = true\n              }\n              pageData = Object.assign(pageData, {\n                webpackCompilationHash: appDataResponse\n                  ? appDataResponse.webpackCompilationHash\n                  : ``,\n              })\n\n              if (typeof rscDataResponse?.payload === `string`) {\n                pageResources = toPageResources(pageData, null, headComponent)\n\n                pageResources.partialHydration = rscDataResponse.payload\n\n                const readableStream = new ReadableStream({\n                  start(controller) {\n                    const te = new TextEncoder()\n                    controller.enqueue(te.encode(rscDataResponse.payload))\n                  },\n                  pull(controller) {\n                    // close on next read when queue is empty\n                    controller.close()\n                  },\n                  cancel() {},\n                })\n\n                return waitForResponse(\n                  createFromReadableStream(readableStream)\n                ).then(result => {\n                  pageResources.partialHydration = result\n\n                  return pageResources\n                })\n              } else {\n                pageResources = toPageResources(\n                  pageData,\n                  pageComponent,\n                  headComponent\n                )\n              }\n            }\n\n            // undefined if final result is an error\n            return pageResources\n          }\n        )\n\n        // get list of static queries to get\n        const staticQueryBatchPromise = Promise.all(\n          dedupedStaticQueryHashes.map(staticQueryHash => {\n            // Check for cache in case this static query result has already been loaded\n            if (this.staticQueryDb[staticQueryHash]) {\n              const jsonPayload = this.staticQueryDb[staticQueryHash]\n              return { staticQueryHash, jsonPayload }\n            }\n\n            return this.memoizedGet(\n              `${__PATH_PREFIX__}/page-data/sq/d/${staticQueryHash}.json`\n            )\n              .then(req => {\n                const jsonPayload = JSON.parse(req.responseText)\n                return { staticQueryHash, jsonPayload }\n              })\n              .catch(() => {\n                throw new Error(\n                  `We couldn't load \"${__PATH_PREFIX__}/page-data/sq/d/${staticQueryHash}.json\"`\n                )\n              })\n          })\n        ).then(staticQueryResults => {\n          const staticQueryResultsMap = {}\n\n          staticQueryResults.forEach(({ staticQueryHash, jsonPayload }) => {\n            staticQueryResultsMap[staticQueryHash] = jsonPayload\n            this.staticQueryDb[staticQueryHash] = jsonPayload\n          })\n\n          return staticQueryResultsMap\n        })\n\n        return (\n          Promise.all([componentChunkPromises, staticQueryBatchPromise])\n            .then(([pageResources, staticQueryResults]) => {\n              let payload\n              if (pageResources) {\n                payload = { ...pageResources, staticQueryResults }\n                finalResult.payload = payload\n                emitter.emit(`onPostLoadPageResources`, {\n                  page: payload,\n                  pageResources: payload,\n                })\n              }\n\n              this.pageDb.set(pagePath, finalResult)\n\n              if (finalResult.error) {\n                return {\n                  error: finalResult.error,\n                  status: finalResult.status,\n                }\n              }\n\n              return payload\n            })\n            // when static-query fail to load we throw a better error\n            .catch(err => {\n              return {\n                error: err,\n                status: PageResourceStatus.Error,\n              }\n            })\n        )\n      })\n    })\n\n    inFlightPromise\n      .then(() => {\n        this.inFlightDb.delete(pagePath)\n      })\n      .catch(error => {\n        this.inFlightDb.delete(pagePath)\n        throw error\n      })\n\n    this.inFlightDb.set(pagePath, inFlightPromise)\n\n    return inFlightPromise\n  }\n\n  // returns undefined if the page does not exists in cache\n  loadPageSync(rawPath, options = {}) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const pageData = this.pageDb.get(pagePath)\n\n      if (pageData.payload) {\n        return pageData.payload\n      }\n\n      if (options?.withErrorDetails) {\n        return {\n          error: pageData.error,\n          status: pageData.status,\n        }\n      }\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Don't prefetch if this is a crawler bot\n    if (navigator.userAgent && BOT_REGEX.test(navigator.userAgent)) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return {\n        then: resolve => resolve(false),\n        abort: () => {},\n      }\n    }\n    if (this.prefetchTriggered.has(pagePath)) {\n      return {\n        then: resolve => resolve(true),\n        abort: () => {},\n      }\n    }\n\n    const defer = {\n      resolve: null,\n      reject: null,\n      promise: null,\n    }\n    defer.promise = new Promise((resolve, reject) => {\n      defer.resolve = resolve\n      defer.reject = reject\n    })\n    this.prefetchQueued.push([pagePath, defer])\n    const abortC = new AbortController()\n    abortC.signal.addEventListener(`abort`, () => {\n      const index = this.prefetchQueued.findIndex(([p]) => p === pagePath)\n      // remove from the queue\n      if (index !== -1) {\n        this.prefetchQueued.splice(index, 1)\n      }\n    })\n\n    if (!this.isPrefetchQueueRunning) {\n      this.isPrefetchQueueRunning = true\n      setTimeout(() => {\n        this._processNextPrefetchBatch()\n      }, 3000)\n    }\n\n    return {\n      then: (resolve, reject) => defer.promise.then(resolve, reject),\n      abort: abortC.abort.bind(abortC),\n    }\n  }\n\n  _processNextPrefetchBatch() {\n    const idleCallback = window.requestIdleCallback || (cb => setTimeout(cb, 0))\n\n    idleCallback(() => {\n      const toPrefetch = this.prefetchQueued.splice(0, 4)\n      const prefetches = Promise.all(\n        toPrefetch.map(([pagePath, dPromise]) => {\n          // Tell plugins with custom prefetching logic that they should start\n          // prefetching this path.\n          if (!this.prefetchTriggered.has(pagePath)) {\n            this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n            this.prefetchTriggered.add(pagePath)\n          }\n\n          // If a plugin has disabled core prefetching, stop now.\n          if (this.prefetchDisabled) {\n            return dPromise.resolve(false)\n          }\n\n          return this.doPrefetch(findPath(pagePath)).then(() => {\n            if (!this.prefetchCompleted.has(pagePath)) {\n              this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n              this.prefetchCompleted.add(pagePath)\n            }\n\n            dPromise.resolve(true)\n          })\n        })\n      )\n\n      if (this.prefetchQueued.length) {\n        prefetches.then(() => {\n          setTimeout(() => {\n            this._processNextPrefetchBatch()\n          }, 3000)\n        })\n      } else {\n        this.isPrefetchQueueRunning = false\n      }\n    })\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n\n    if (global.hasPartialHydration) {\n      return Promise.all([\n        prefetchHelper(pageDataUrl, {\n          crossOrigin: `anonymous`,\n          as: `fetch`,\n        }).then(() =>\n          // This was just prefetched, so will return a response from\n          // the cache instead of making another request to the server\n          this.loadPageDataJson(pagePath)\n        ),\n        prefetchHelper(pageDataUrl.replace(`.json`, `-rsc.json`), {\n          crossOrigin: `anonymous`,\n          as: `fetch`,\n        }).then(() =>\n          // This was just prefetched, so will return a response from\n          // the cache instead of making another request to the server\n          this.loadPartialHydrationJson(pagePath)\n        ),\n      ])\n    } else {\n      return prefetchHelper(pageDataUrl, {\n        crossOrigin: `anonymous`,\n        as: `fetch`,\n      }).then(() =>\n        // This was just prefetched, so will return a response from\n        // the cache instead of making another request to the server\n        this.loadPageDataJson(pagePath)\n      )\n    }\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return !page || page.notFound\n  }\n\n  loadAppData(retries = 0) {\n    return this.memoizedGet(`${__PATH_PREFIX__}/page-data/app-data.json`).then(\n      req => {\n        const { status, responseText } = req\n\n        let appData\n\n        if (status !== 200 && retries < 3) {\n          // Retry 3 times incase of non-200 responses\n          return this.loadAppData(retries + 1)\n        }\n\n        // Handle 200\n        if (status === 200) {\n          try {\n            const jsonPayload = JSON.parse(responseText)\n            if (jsonPayload.webpackCompilationHash === undefined) {\n              throw new Error(`not a valid app-data response`)\n            }\n\n            appData = jsonPayload\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        return appData\n      }\n    )\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  (window.___chunkMapping[componentChunkName] || []).map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths, pageData) {\n    const loadComponent = (chunkName, exportType = `components`) => {\n      if (!global.hasPartialHydration) {\n        exportType = `components`\n      }\n\n      if (!asyncRequires[exportType][chunkName]) {\n        throw new Error(\n          `We couldn't find the correct component chunk with the name \"${chunkName}\"`\n        )\n      }\n\n      return (\n        asyncRequires[exportType][chunkName]()\n          // loader will handle the case when component is error\n          .catch(err => err)\n      )\n    }\n\n    super(loadComponent, matchPaths)\n\n    if (pageData) {\n      this.pageDataDb.set(findPath(pageData.path), {\n        pagePath: pageData.path,\n        payload: pageData,\n        status: `success`,\n      })\n    }\n  }\n\n  doPrefetch(pagePath) {\n    return super.doPrefetch(pagePath).then(result => {\n      if (result.status !== PageResourceStatus.Success) {\n        return Promise.resolve()\n      }\n      const pageData = result.payload\n      const chunkName = pageData.componentChunkName\n      const componentUrls = createComponentUrls(chunkName)\n      return Promise.all(componentUrls.map(prefetchHelper)).then(() => pageData)\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        if (shouldAbortFetch(rawPath)) {\n          return data\n        }\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n\n  loadPartialHydrationJson(rawPath) {\n    return super.loadPartialHydrationJson(rawPath).then(data => {\n      if (data.notFound) {\n        if (shouldAbortFetch(rawPath)) {\n          return data\n        }\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  // TODO add deprecation to v4 so people use withErrorDetails and then we can remove in v5 and change default behaviour\n  loadPageSync: (rawPath, options = {}) =>\n    instance.loadPageSync(rawPath, options),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n\nexport function getStaticQueryResults() {\n  if (instance) {\n    return instance.staticQueryDb\n  } else {\n    return {}\n  }\n}\n\nexport function getSliceResults() {\n  if (instance) {\n    return instance.slicesDb\n  } else {\n    return {}\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}